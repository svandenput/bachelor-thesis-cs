\ProvidesFile{rutitlepage.dtx}[2022/02/21 v3.0 Radboud University Titlepage]
\documentclass{ltxdoc}
\include{macros}
\usepackage{float}
\usepackage{graphicx}
\usepackage{array}
\usepackage[utf8]{inputenc}
\usepackage{rutitlepage}
\usepackage{fancyhdr}
\usepackage[style=ieee]{biblatex}
\usepackage[operators]{cryptocode}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\addbibresource{cryptobib/crypto.bib}
\addbibresource{references.bib}
\GetFileInfo{rutitlepage.dtx}
\newtheorem{theorem}{Theorem}

\pagestyle{fancy}
\fancyhf{}
\lhead{Bachelor Thesis}
\rhead{Page \thepage}

\title{Bachelor Thesis Stijn Vandenput}
\author{stijnvandenput }

\begin{document}
\maketitleru[
    layout=traditional,
    authors={Stijn Vandenput},
    authorstext={Author:},
    nextpagenr={-1},
    institution={Radboud University},
    others={external supervisor:}{Martijn Stam\\\vspace*{0,3cm}
    \textit{internal supervisor:}\\
    Bart Mennink\\\vspace*{0,3cm}
    \textit{second reader:}\\
    Joan Daemen},
    course={Bachelor Thesis},
    title={Lock-based Authenticated Encryption in a Multi-user Setting}]

\begin{abstract}
    \noindent In the context of symmetric encryption, primitives are usually evaluated in a single-user setting. The security bounds found by these evaluations often degrade in a multi-user setting. To prevent this degradation, Giacon, Kiltz and Poettering propose giving a primitive a new input to distinguish between users within the context of hybrid encryption (PKC 2018). In this work, where we refer to this new input as a lock, we investigate how these locks work in a broader context by looking at the generic composition of authenticated encryption. We do this by first formalizing authenticated encryption using locks and then looking at different compositions following insights from Namprempre, Rogaway and Shrimpton (Eurocrypt 2014). We investigate three generic composition methods using locks and conclude that all three are secure.
\end{abstract}
\pagenumbering{roman}
\newpage
\tableofcontents

\newpage
\pagenumbering{arabic}

\section{Introduction}
To be able to safely send a message between two parties, this message needs to be encrypted. For this encryption, a secret shared key is needed. Whenever multiple messages are sent, a new key should be used for every message to ensure forward secrecy of messages. As establishing a new key can be expensive, public-key encryption uses a long-term key to generate ephemeral keys. Public-key encryption is typically implemented using a hybrid paradigm: To encrypt a message, an ephemeral key is generated from the long-term key using a randomized key encapsulation mechanism (KEM). This key is then used to encrypt the message using a deterministic data encapsulation mechanism (DEM). Both the KEM and DEM output their respective ciphertexts, which are then concatenated to form the public-key encryption ciphertext.
\\\\
Classical analysis of DEMs considers a single user. Therefore, the security bounds of these analyses do not always transfer to the real world where one can have millions of users. To make sure the security bounds are also good when there are many users, one can use larger ephemeral keys. Although using these larger keys for DEMs is generally safer, expanding the size of the key might not always be a viable option. This can be due to limitations in computing power or memory, as well as security primitives having fixed key sizes. As an alternative solution to key expansion in a multi-user setting, Giacon, Kiltz and Poettering, henceforth \gkp{}, propose augmentation using locks \cite{PKC:GiaKilPoe18} (originally called tags, but renamed to locks here to avoid overloaded terms). This augmentation gives the security primitive a lock as an additional input field to distinguish multiple users using the same key. The augmentation can improve security in a multi-user setting, without the need to expand the key. After defining this augmentation, GKP apply the augmentation to a DEM and a MAC function, to create an augmented DEM (ADEM) and an augmented MAC (AMAC). These two primitives are combined afterwards to construct an authenticated encryption primitive which is proven secure whenever the ADEM and AMAC are secure. When constructing this authenticated encryption primitive, the generic encrypt-then-MAC composition from Bellare and Namprempre \cite{AC:BelNam00} is used.
\\\\
Although the ADEM+AMAC composition given by GKP is secure, it is not clearly defined as an authenticated encryption primitive. As a result, its security is evaluated as a DEM, instead of as an authenticated encryption primitive. Additionally, we should note that the generic composition of authenticated encryption has, since the original study of Bellare and Namprempre, been revised by Namprempre, Rogaway and Shrimpton \cite{EC:NamRogShr14}, which we henceforth call \nrs{}. In this revision, the generic composition using a MAC function and a deterministic encryption primitive is more thoroughly investigated. The original study found only the encrypt-then-MAC composition to be secure. NRS shine light on the fact that the security of the generic compositions depends on the kind of encryption primitives used, as well as the desired end result. Hence, the composition should be re-evaluated if the context changes. To continue, they evaluate all possible generic compositions using a nonce-based encryption primitive and a MAC function. When using these to construct nonce-based authentication, three composition methods called encrypt-and-MAC, encrypt-then-MAC and MAC-then-encrypt are proven to be secure whenever the underlying primitives are secure.
\\\\
In this thesis, the generic composition of authenticated encryption using locks is more thoroughly investigated. This investigation will lead to a better understanding of the security of locks, and in which context it is a viable solution to security degradation in a multi-user setting. Additionally, we will define a specification of the lock-based authenticated encryption primitives, which. This specification, combined with three different generic compositions that we prove secure, will be a first step towards using the locks outside the context of hybrid encryption. We formally compare the constructions and the notation from NRS and GKP (Section 3). To evaluate generic composition using locks, we define a new cryptographic primitive which we analyze in a multi-user setting (Section 4). Using the knowledge from NRS, three generic compositions (encrypt-and-MAC, encrypt-then-MAC and MAC-then-encrypt) of this primitive are considered, all using a lock-based encryption primitive and a lock-based MAC function (Section 5). We prove these three compositions to be secure, whenever the underlying primitives are secure (Section 6). Afterwards, some use cases of the new primitive are discussed (Section 7). 

\section{Preliminaries}
In this section, we will explain several concepts important to the rest of our work, as well as some general notation.

\subsection{General Notation}
Unless otherwise stated, strings are assumed to be binary and the set of all strings is $\{0,1\}^\ast$. The length of $x$ is written as $\abs{x}$, the concatenation of $x$ and $y$ as $x$ \concatinate{} $y$, $a$ being the result of $b$ as $a$ \result{} $b$, and taking a uniform random sampling from set $z$ and assigning it to $x$ as $x$ \sample{} $z$. We write \users{} for the number of users and allow a single type of error message written as \invalid. Any tuple containing \invalid{} will be \invalid{} as well. We define the following spaces, all of them being subsets of the set of all strings: nonempty key space \keyspace{}, lock space \lockspace{}, nonce space \noncespace{}, message space \messagespace{}, ciphertext space \ciphertextspace, tag space \tagspace{}, and associated data space \associateddataspace{}. Unless stated otherwise, \messagespace{} contains at least two strings, and if \messagespace{} or \associateddataspace{} contains a string of length $x$, it must contain all strings of length $x$. There are no further constraints on these spaces.

\subsection{Authenticated Encryption}
Two different security requirements are data privacy, the insurance that data cannot be viewed by an unauthorized party, and data integrity, the insurance that data has not been modified by an unauthorized party. Authenticated encryption combines both of these security requirements into one and ensures both data privacy and integrity. A basic authenticated encryption scheme consists of an encryption call and a decryption call. The encryption call takes a message and a key to a self-authenticating ciphertext while the decryption call takes a self-authenticating ciphertext and a key to a message. Some authenticated encryption schemes allow an additional input AD, short for associated data. The associated data is specifically required to not have data privacy but does require data integrity. When an authenticated encryption scheme supports AD, it is called an AEAD scheme.

\subsection{Message Authentication}
Message authentication can be done using a message authentication code, MAC for short. A basic MAC function takes a message and key and outputs a tag that authenticates the message. Some MAC functions also have a verification call that takes in a message, key and tag and outputs either \codetrue{} or \codefalse. A MAC function can have different security requirements. It is said to be PRF secure when it is infeasible to distinguish the output tag from the result of a pseudo-random function that takes all possible message-key pairs to the tag space. A MAC is said to be unforgeable when it is infeasible to create a valid message-tag pair without knowledge of the secret key. A PRF secure MAC is also unforgeable, given the tag space is big enough, while an unforgeable MAC is not necessarily PRF secure.

\subsection{Nonces and Locks}
A basic deterministic encryption scheme takes a message and key as input and outputs a ciphertext. Using this encryption scheme, a message encrypted under the same key leads to the same ciphertext. Both GKP (Giacon, Kiltz and Poettering) and NRS (Namprempre, Rogaway and Shrimpton) resolve this by giving the encryption scheme an additional argument. GKP use locks while NRS use nonces. Although nonces and locks look similar, their purpose and exact working differ leading to different use cases. Most notably, nonces are only useful when one user is allowed to encrypt multiple messages while locks are only useful when there are multiple users.

\paragraph{Nonces}
Using a basic deterministic encryption scheme, a message encrypted twice by the same user using the same key results in the same ciphertext. This can leak information about the message, which can be prevented by using a nonce. A nonce is a number that is assumed to only be used once per user to encrypt a message. Whenever a message is encrypted twice with the same key, but with two different nonces, the resulting ciphertexts should be indistinguishable from two ciphertexts corresponding to two different messages. As a result, it is infeasible for an adversary to guess if a message has been sent multiple times. When evaluating the security, the adversary is usually allowed to let a user decrypt multiple messages with a single nonce. Nonces are only used when a user uses its key multiple times, as otherwise a message will never be encrypted by the same user twice.

\paragraph{Locks}
Using a basic deterministic encryption scheme, a message encrypted by two users that have the same key results in the same ciphertext. This can leak information about the secret keys used, which can be prevented by using locks. Whereas nonces are bound to the message, locks are bound to the user. Each user has one lock, provided the users have one key each, and will encrypt all their messages using that lock. Whenever a message is encrypted twice with the same key, but with two different locks, the resulting ciphertexts should be indistinguishable from two ciphertexts corresponding to two different messages. As a result, it is infeasible for an adversary to see when two users have a key collision unless locks collide as well. To prevent collisions in locks, we assume locks to be globally unique. The adversary is usually only allowed to let a user decrypt messages with the correct lock. Locks are only used in a multi-user setting, as key collision is impossible when there is only one user.  

\subsection{Security Notions}
The security of a cryptographic construction can be modeled as a distinguishing advantage. When doing this, different security notions are formed based on what one distinguishes on. To understand NRS and GKP as well as how they differ, it is important to understand which security notions they use. All the relevant notions are written below.

\paragraph{Active, Passive or Authenticated Encryption}
Security can be modeled against a passive or an active attacker. A passive attacker can only read the messages while an active attacker can also alter the messages. A passive attacker can be modeled using a chosen plaintext attack, CPA for short. In this model, the adversary can choose the plaintext that is encrypted, but not the ciphertext that is decrypted. An active attacker can be modeled using a chosen ciphertext attack, CCA for short. In this model, the adversary can choose the plaintext that is encrypted, as well as the ciphertext that is decrypted. A Stricter version of the CCA model is the Authenticated Encryption model, AE for short. This model combines CCA with the requirement that the adversary can not forge a valid ciphertext. Shorthand notations for the three are IND-CPA, IND-CCA, and IND-AE respectively. IND-CCA implies IND-CPA, but not the other way around. Similarly, IND-AE implies IND-CCA, but not the other way around. Both GKP and NRS model the underlying encryption primitive using IND-CPA. They differ in how they model the authenticated encryption primitive, GKP uses IND-CCA for this while NRS uses IND-AE.

\paragraph{\$ or Left-or-right}
Left-or-right-indistinguishablility refers to a situation where the adversary gives two messages and in return receives a ciphertext. To break the security, the adversary has to guess which of the two messages corresponds to the ciphertext. \$-indistinguishability refers to a situation where the adversary is given access to either the real construction or to a lazily sampled random function \$. This random function returns a random string with the same length as the ciphertext would have. To break the security, the adversary has to guess which of the two it has access to. As long as the length of the ciphertext only depends on the length of the message, not its content, IND-\$ implies IND-LOR, but not the other way around. IND-\$ is used by GKP and IND-LOR is used by NRS.
\\\\
Both the power of the adversary and the indistinguishability are separate dimensions that can be combined into six different notions. For example, IND-\$-CCA refers to a situation where the adversary has to distinguish between the real construction, or a random function while being able to choose both the plaintext that is encrypted and the ciphertext that is decrypted.

\paragraph{Game Based Security Notions}
These security notions can be written in a game-based format, using pseudocode instead of text. As an example, the IND-\$-CPA game of a nonce-based encryption scheme can be found in Figure \ref{fig: nE-IND game}. A challenge bit $b$ is given to the game, in this case, $b$ signals whether we are in the real or the ideal world. The adversary guesses this bit and returns $b'$, signaling its guess for $b$. In addition, the adversary can have access to oracles which represent queries to users. In our example, there is only the encryption oracle that takes a nonce and a message. Using game-based notation, one can write out all the limitations clearly. For example, the limitation that nonces cannot be reused is modeled by lines 0, 5 and 6. Lines 8 and 9 model how the random function \$ behaves. Although these limitations could be written out in text-based format as well, writing it out in a game-based format can make the security notion, as well as the security proofs, more comprehensible and precise.

\subsection{Security Proofs of Generic Composition}
To prove the security of a generic composition we can use a security reduction. To define a reduction we bind the advantage on the generic composition in terms of the advantages on the underlying primitives. This can be done by proving that, if we can break the security of the generic composition, then we can use this to break the security of one of the underlying primitives as well. After proving this, we can conclude that the composition is secure, as long as the underlying primitives are secure. A security reduction is said to be loose when it is linear in the amount of users and tight when it is constant. 

\section{\nrs{} and \gkp{} in Detail}
In this section, we explain the parts of the papers from \gkp{} and \nrs{} that are important to our work. Afterwards, a comparison is made between the two. Some notations will be different from the original papers for improved consistency. What are called tags by \gkp, we will call locks instead to avoid confusion with the output of MAC functions. Similarly, we call the output of the AMAC the tag, instead of the ciphertext. The security notions from \nrs{} are converted to a game-based format using insights from Cremers et al. \cite{USENIX:CrAlJaZh23} to better match the notation from \gkp{} and be more adaptable to a multi-user setting. These security games are only explained briefly in this section, a more in-depth explanation of the relevant constructions can be found in Section \ref{sec: lAE security model}.

\subsection{\nrs}
Three generic ways to compose an authenticated encryption scheme are discussed in a paper written by Bellare and Namprempre \cite{AC:BelNam00}: encrypt-then-MAC, encrypt-and-MAC and MAC-then-encrypt. In that paper, encrypt-then-MAC is considered the only secure composition when using probabilistic encryption as a building block. \nrs{} note that the type of encryption scheme used, as well as the desired end result influences which compositions are secure. Consequently, the result from Bellare en Namprempre is only applicable when using probabilistic encryption. Afterward, all generic compositions are defined using a nonce-based encryption scheme, nA for short, and a PRF secure MAC function to create a nonce-based authenticated encryption scheme, nAE for short. With these primitives, they find all three earlier named compositions to be secure. Note that NRS include Associated Data (AD) in the authenticated encryption primitive. Below we describe the primitives, their security, and the compositions more in depth.

\subsubsection{Primitives}
\paragraph{nE}
A nonce-based encryption scheme is defined by a triple $\mathit{\Pi}$ = $(\keyspace{},\text{E},\text{D})$. Deterministic encryption algorithm E takes three inputs $(\keyinstance,\nonceinstance,\messageinstance)$ and outputs a value \ciphertextinstance, the length of \ciphertextinstance{} only depends on the lengths of \keyinstance, \nonceinstance{} and \messageinstance. If, and only if, $(\keyinstance,\nonceinstance,\messageinstance)$ is not in $\keyspace \times \noncespace \times \messagespace$, \ciphertextinstance{} will be \invalid. Decryption algorithm D takes three inputs $(\keyinstance,\nonceinstance,\ciphertextinstance)$ and outputs a value \messageinstance. Both E and D are required to satisfy correctness (if E$(\keyinstance,\nonceinstance,\messageinstance)$ $= \ciphertextinstance \neq \invalid$, then D$(\keyinstance,\nonceinstance,\ciphertextinstance)$ = \messageinstance) and tidiness (if D$(\keyinstance,\nonceinstance,\ciphertextinstance)$ $= \messageinstance \neq \invalid$, then E$(\keyinstance,\nonceinstance, \messageinstance)$ = \ciphertextinstance).

\paragraph{nE security}
The security of a nE is defined as 
\begin{align*} 
    \text{\advantage{$\mathit{\Pi}$,\adversary}{nE} = \probabilityblock{nE-IND-\$-CPA}{\adversary}{0}{1}}
\end{align*}
where nE-IND-\$-CPA is in Figure \ref{fig: nE-IND game}. Set $U$ keeps track of all used nonces as the adversary is not allowed to repeat nonces.
\begin{figure}
    \centering
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} nE-IND-\$-CPA$^{b}_{\adversary}$ }]{
            U \result \emptyset\\
            \keyinstance \sample \keyspace\\
            b' \result \adversary\\
            \pcreturn b'
        }
        \pseudocode[lnstart=4,linenumbering,head={\textbf{Oracle} Oenc$(\nonceinstance,\messageinstance)$}]{
            \pcif \nonceinstance \in U : \pcreturn \invalid\\
            U \result U \cup \{\nonceinstance\}\\
            \ciphertextinstance \result \text{E}(\keyinstance,\nonceinstance,\messageinstance)\\
            \pcif b = 1 \wedge \ciphertextinstance \neq \invalid: \\
            \t \ciphertextinstance \sample \{0,1\}^{\abs{\ciphertextinstance}}\\
            \pcreturn \ciphertextinstance
        }
    \end{pchstack}
    \caption{nE-IND-\$-CPA game, \adversary{} has access to oracle Oenc.}
    \label{fig: nE-IND game}
\end{figure}
    
\paragraph{MAC}
A MAC is defined by an algorithm F that takes a key \keyinstance{} in \keyspace{} and a string \messageinstance{} and outputs either a n-bit tag \taginstance{} or \invalid. The domain of F is the set $X$ such that F$(\keyinstance,\messageinstance)\neq \invalid$ is in $X$, this domain may not depend on \keyinstance.

\paragraph{MAC security}
NRS require the MAC to be PRF secure. The security is defined as 
\begin{align*} 
    \text{\advantage{F,\adversary}{MAC} = \probabilityblock{MAC-PRF}{\adversary}{0}{1}}
\end{align*}
where MAC-PRF is in Figure \ref{fig: MAC-PRF}. In this game, the set $U$ keeps track of the used messages to prevent the adversary from trivially winning the security game.
    \begin{figure}
        \centering
        \begin{pchstack}[boxed,center,space=0.5cm]
            \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} MAC-PRF$^{b}_{\adversary}$ }]{
                U \result \emptyset\\
                \keyinstance \sample \keyspace\\
                b' \result \adversary\\
                \pcreturn b'
            }
            \pseudocode[lnstart=3,linenumbering,head={\textbf{Oracle} Omac(\messageinstance)}]{
                \pcif \messageinstance \in U : \pcreturn \invalid\\
                U \result U \cup \{\messageinstance\}\\
                \taginstance \result \text{F}(\keyinstance,\messageinstance)\\
                \pcif b = 1 \wedge \taginstance \neq \invalid: \\
                \t \taginstance \sample \{0,1\}^{\abs{\taginstance}}\\
                \pcreturn \taginstance
            }
        \end{pchstack}
        \caption{MAC-PRF, \adversary{} has access to oracle Omac and $U$ is the set of used messages.}
        \label{fig: MAC-PRF}
    \end{figure}

\paragraph{nAE}
A nonce-based authenticated encryption scheme is defined by a triple $\mathit{\Pi}$ = $(\keyspace{},\text{E},\text{D})$. Deterministic encryption algorithm E takes four inputs $(\keyinstance,\nonceinstance,\associateddatainstance,\messageinstance)$ and outputs a value \ciphertextinstance, the length of \ciphertextinstance{} only depends on the lengths of \keyinstance, \nonceinstance, \associateddatainstance{} and \messageinstance. If, and only if, $(\keyinstance,\nonceinstance,\associateddatainstance,\messageinstance)$ is not in $\keyspace \times \noncespace \times \associateddataspace \times \messagespace$, \ciphertextinstance{} will be \invalid. Decryption algorithm D takes four inputs $(\keyinstance,\nonceinstance,\associateddatainstance,\ciphertextinstance)$ and outputs a value \messageinstance. Both E and D are required to satisfy correctness (if E$(\keyinstance,\nonceinstance,\associateddatainstance,\messageinstance)$ $= \ciphertextinstance \neq \invalid$, then D$(\keyinstance,\nonceinstance,\associateddatainstance,\ciphertextinstance)$ = \messageinstance) and tidiness (if D$(\keyinstance,\nonceinstance,\associateddatainstance,\ciphertextinstance)$ $= \messageinstance \neq \invalid$, then E$(\keyinstance,\nonceinstance,\associateddatainstance,\messageinstance)$ = \ciphertextinstance).

\paragraph{nAE security}
The security of a nAE is defined as 
\begin{align*} 
 \text{\advantage{$\mathit{\Pi}$,\adversary}{nAE} = \probabilityblock{nAE-IND-\$-AE}{\adversary}{0}{1}}
\end{align*}
where nAE-IND-\$-AE is in Figure \ref{fig: nAE-IND game}. The adversary is not allowed to repeat nonces on encryption. Set $U$ keeps track of all used nonces. Following the translation of IND-\$-AE to a security game for AE from Cremers et al. \cite{USENIX:CrAlJaZh23}, \_ denotes a variable that is irrelevant and set $Q$ keeps track of all query results to prevent trivial wins.
    \begin{figure}
        \centering
        \begin{pchstack}[boxed,center,space=0.5cm]
            \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} nAE-IND-\$-AE$^{b}_{\adversary}$ }]{
                U \result \emptyset\\
                Q \result \emptyset\\
                \keyinstance \sample \keyspace\\
                b' \result \adversary\\
                \pcreturn b'
            }
            \pseudocode[lnstart=5,linenumbering,head={\textbf{Oracle} Oenc$(\nonceinstance,\associateddatainstance,\messageinstance)$}]{
                \pcif \nonceinstance \in U : \pcreturn \invalid\\
                U \result U \cup \{\nonceinstance\}\\
                \pcif (\nonceinstance,\associateddatainstance,\messageinstance,\_) \in Q : \pcreturn \invalid\\
                \ciphertextinstance \result \text{E}(\keyinstance,\nonceinstance,\associateddatainstance,\messageinstance)\\
                \pcif b = 1 \wedge \ciphertextinstance \neq \invalid: \\
                \t \ciphertextinstance \sample \{0,1\}^{\abs{\ciphertextinstance}}\\
                Q \result Q \cup \{(\nonceinstance,\associateddatainstance,\messageinstance,\ciphertextinstance)\}\\
                \pcreturn \ciphertextinstance
            }
            \pseudocode[lnstart=13,linenumbering,head={\textbf{Oracle} Odec$(\nonceinstance,\associateddatainstance,\ciphertextinstance)$}]{
                \pcif b = 1 : \pcreturn \invalid\\
                \pcif (\nonceinstance,\associateddatainstance,\_,\ciphertextinstance) \in Q : \pcreturn \invalid\\
                \messageinstance \result \text{D} (\keyinstance,\nonceinstance,\associateddatainstance,\ciphertextinstance)\\
                Q \result Q \cup \{(\nonceinstance,\associateddatainstance,\messageinstance,\ciphertextinstance)\}\\
                \pcreturn \messageinstance
            }
        \end{pchstack}
        \caption{nAE-IND-\$-AE game, \adversary{} has access to oracles Oenc and Odec.}
        \label{fig: nAE-IND game}
    \end{figure}

\subsubsection{Composition}
NRS define 20 different schemes that compose an nAE from an nE and a MAC function. They define a composition to be secure if there is a tight reduction from breaking the nAE-security of the scheme to breaking the nE-security and the PRF security of the underlying primitives. Three different schemes, named N1, N2 and N3, were proven to be secure. Noteworthy is that these relate to encrypt-and-MAC, encrypt-then-MAC and MAC-then-encrypt, respectively. Additionally, they propose a scheme N4, for which they can not prove it secure, nor find a counterexample to prove it is insecure. However, this case has since been proven to be insecure as well \cite{INDOCRYPT:BerPerPet18} so is not considered here. All four schemes can be viewed in Figure 6 of the original paper by \nrs{}.

\subsection{\gkp}
\gkp{} discuss the concept of augmentation using locks to prevent security degradation in a multi-user setting. They start by showing how some data encapsulation mechanisms are vulnerable to both a passive multi-instance distinguishing attack and a key recovery attack. These vulnerabilities lead to the degradation of the security bounds found in analyses considering only a single user. As an alternative solution to expanding the key size, they define augmentation using locks. When augmenting with a lock, you introduce a new input value which is assumed to be unique per user. Unlike the key, the lock is not secret. They show how you can augment both a DEM and a MAC to get an ADEM and AMAC respectively. Afterward, they combine these two to construct an ADEM that is safe against active attackers. Below we describe the primitives, their security, and their composition more in-depth.

\subsubsection{Primitives}
\paragraph{ADEM}
An ADEM scheme is defined by a tuple $(\text{A.enc}, \text{A.dec})$. Deterministic algorithm A.enc takes a key \keyinstance{} in \keyspace{}, a lock \lockinstance{} in \lockspace{} and a message \messageinstance{} in \messagespace{} and outputs a ciphertext \ciphertextinstance{} in \ciphertextspace{}.  Deterministic algorithm A.dec takes a \keyinstance{} in \keyspace{}, a lock \lockinstance{} in \lockspace{} and a ciphertext \ciphertextinstance{} in \ciphertextspace{} and outputs a message \messageinstance{} in \messagespace{} or \invalid{} to indicate rejection. The correctness requirement is that for every combination of \keyinstance{}, \lockinstance{} and \messageinstance{} we have A.dec$(\keyinstance,\lockinstance,\text{A.enc}(\keyinstance,\lockinstance,\messageinstance))$ = \messageinstance. We will consider both CPA and CCA security separately for this scheme.

\paragraph{ADEM security}
The security of an ADEM, is defined as 
\begin{align*} 
    \text{\advantage{ADEM,\adversary,\users}{l-ind-lor} = \probabilityblock{L-IND-LOR}{\adversary,\users}{0}{1}}
\end{align*}
where L-IND-LOR is in Figure \ref{fig: L-IND game}. Every user is only allowed one encryption query as enforced by lines 3, 6 and 11. Locks may not repeat between users as enforced by lines 0, 7, 8 and 9. Decryption queries are only allowed after the given user made an encryption as enforced by lines 3, 11 and 13. Line 14 prevents trivial distinctions. Note that the figure includes a decryption oracle. When considering the CPA security of an ADEM, the adversary is not allowed to use this oracle. 

\begin{figure}
    \centering
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} L-IND-LOR$^{b}_{\adversary,\users}$ }]{
        L \result \emptyset\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace\\
        \t C_\user \result \emptyset\\
        b' \result \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=5,linenumbering,head={\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance_0,\messageinstance_1)$}]{
            \pcif C_\user \neq \emptyset: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            \ciphertextinstance \result \text{A.enc'}(\keyinstance_\user,\lockinstance_\user,\messageinstance_b)\\
            C_\user \result C_\user \cup \{\ciphertextinstance\}\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=12,linenumbering,head={\textbf{Oracle} Odec(\user,\ciphertextinstance)}]{
            \pcif C_\user = \emptyset: \pcreturn \invalid\\
            \pcif \ciphertextinstance \in C_\user: \pcreturn \invalid\\
            \messageinstance \result \text{A.dec'}(\keyinstance_\user,\lockinstance_\user,\ciphertextinstance)\\
            \pcreturn \messageinstance
        }
    \end{pchstack}
    \caption{L-IND-LOR, \adversary{} has access to oracles Oenc and Odec. The locks in lines 10 and 15 are the same. The corresponding game can be found in Figure 9 from \gkp{}}
    \label{fig: L-IND game}
\end{figure}

\paragraph{AMAC}
An AMAC scheme is defined by a tuple $(\text{M.mac},\text{M.vrf})$. Deterministic algorithm M.mac takes a key \keyinstance{} in \keyspace{}, a lock \lockinstance{} in \lockspace{}, and a message \messageinstance{} in \messagespace{} and outputs a tag \taginstance{} in \tagspace{}. Deterministic algorithm M.vrf takes a key \keyinstance{} in \keyspace{}, a lock \lockinstance{} in \lockspace{}, a message \messageinstance{} in \messagespace{} and a tag \taginstance{} in \tagspace{} and returns either \codetrue{} or \codefalse. The correctness requirement is that for every combination of \keyinstance{}, \lockinstance{} and \messageinstance{}, all corresponding \taginstance{} \result M.mac$(\keyinstance,\lockinstance,\messageinstance)$ gives M.vrf$(\keyinstance,\lockinstance,\messageinstance,\taginstance)$ = \codetrue. 

\paragraph{AMAC security}
The security of an AMAC is defined as
\begin{align*} 
 \text{\advantage{AMAC,\adversary,\users}{L-MIOT-UF} = $\text{Pr}[\text{L-MIOT-UF}_{\adversary,\users} = 1]$}
\end{align*}
where L-MIOT-UF is in Figure \ref{fig: L-MIOT-UF game}. Every user is only allowed one MAC query as enforced by lines 4, 7 and 12. Locks may not repeat between users as enforced by lines 1, 8, 9 and 10. Verification queries are only allowed after the user makes a MAC query as enforced by lines 4, 12 and 14. Line 15 prevents trivial distinctions.
\begin{figure}
    \centering
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} L-MIOT-UF$_{\adversary,\users}$ }]{
        \text{forged} \result 0\\
        L \result \emptyset\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace\\
        \t T_\user \result \emptyset\\
        \textbf{run } \adversary\\
        \pcreturn \text{forged}
        }
        \pseudocode[lnstart=6,linenumbering,head={\textbf{Oracle} Omac$(\user,\lockinstance,\messageinstance)$}]{
            \pcif T_\user \neq \emptyset: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            \taginstance \result \text{M.mac}(\keyinstance_\user,\lockinstance_\user,\messageinstance)\\
            T_\user \result T_\user \cup \{(\messageinstance,\taginstance)\}\\
            \pcreturn \taginstance
        }
        \pseudocode[lnstart=13,linenumbering,head={\textbf{Oracle} Ovrf$(\user,\messageinstance,\taginstance)$}]{
            \pcif T_\user = \emptyset: \pcreturn \invalid\\
            \pcif (\messageinstance,\taginstance) \in T_\user: \pcreturn \invalid\\
            \pcif \text{M.vrf}(\keyinstance_\user,\lockinstance_\user,\messageinstance,\taginstance): \\
            \t \text{forged} \result 1\\
            \t \pcreturn \codetrue\\
            \pcelse : \pcreturn \codefalse
        }
    \end{pchstack}
    \caption{L-MIOT-UF game, \adversary{} has access to oracles Omac and Ovrf. The locks in lines 11 and 16 are the same. The corresponding game can be found in Figure 15 of \gkp{}.}
    \label{fig: L-MIOT-UF game}
\end{figure}

\paragraph{Definitional Differences}
\gkp{} do not require \messagespace{} to contain at least two strings, and to contain all strings of length $x$ if it contains a string of length $x$. Additionally, \keyspace{} is required to be finite but not required to be non-empty.

\subsubsection{Composition}
\gkp{} construct an ADEM scheme that is CCA secure, using an ADEM scheme that is CPA secure and an AMAC scheme. Their composition follows the encrypt-then-MAC method from Bellare and Namprempre \cite{AC:BelNam00} and is thus similar to composition N2 from \nrs. The algorithms A.enc and A.dec that form the CCA-secure ADEM are in Figure \ref{fig: A.enc and A.dec calls}. Note that in this figure, A.enc$'$ and A.dec$'$ refer to the A.enc and A.dec from the underlying CPA-secure ADEM.
\begin{figure}
    \centering
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Proc} A.enc$(\keyinstance,\lockinstance,\messageinstance)$}]{
        (\keyinstance_{dem},\keyinstance_{mac}) \result \keyinstance\\
        \ciphertextinstance' \result \text{A.enc}'(\keyinstance_{dem},\lockinstance,\messageinstance)\\
        \taginstance \result \text{M.mac}(\keyinstance_{mac},\lockinstance,\ciphertextinstance')\\
        \ciphertextinstance \result (\ciphertextinstance',\taginstance)\\
        \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=4,linenumbering,head={\textbf{Proc} A.dec$(\keyinstance,\lockinstance,\ciphertextinstance)$}]{
            (\keyinstance_{dem},\keyinstance_{mac}) \result \keyinstance\\
            (\ciphertextinstance',\taginstance) \result \ciphertextinstance\\
            \pcif \text{M.vrf}(\keyinstance_{mac},\lockinstance,\ciphertextinstance',\taginstance):\\
            \t \messageinstance \result \text{A.dec}'(\keyinstance_{dem},\lockinstance,\ciphertextinstance')\\
            \t \pcreturn \messageinstance\\
            \pcelse : \pcreturn \invalid
        }
    \end{pchstack}
    \caption{A.enc and A.dec algorithms, the algorithms calls can be found in Figure 16 of \gkp{}. A.enc$'$ and A.dec$'$ refer to the A.enc and A.dec from the CPA-secure ADEM}
    \label{fig: A.enc and A.dec calls}
\end{figure}
\noindent They define the composition to be secure as there is a tight reduction from breaking the CCA security of the ADEM to breaking the CPA security of the underlying ADEM or the AMAC security of the underlying AMAC.

\subsection{Comparison of \gkp{} and \nrs}
In this section, we will highlight how \gkp{} and \nrs{} differ, as well as why.

\paragraph{Context and Aim}
Historically, a single user that reuses a single key is considered in a symmetric context, \nrs{} follow this trend as they wrote in this context. In contrast, \gkp{} wrote in the context of hybrid encryption, a context that considers multiple users that use their encryption key once. Apart from this difference in context, there is also a different aim. While \nrs{} aim to generalize the generic nAE composition, \gkp{} aim to find a single composition that can be used for hybrid encryption. Most notably, this results in \nrs{} evaluating 20 possible compositions while \gkp{} evaluate one. Additionally, \nrs{} incorporate AD while \gkp{} do not.

\paragraph{Security Notion}
The security notions from both papers also reflect the differences in contexts. \nrs{} write the security notions in a IND-\$-AE fashion, common in symmetric cryptography. Conversely, \gkp{} write them in an IND-LOR-CPA fashion, common in Hybrid encryption. As a result, the MAC primitives of the two papers have different security requirements. \nrs{} require the tag to be indistinguishable from a random string while \gkp{} require the tag to be unforgeable. Additionally, NRS models a situation in which the adversary can not forge a valid cythertext while GKP does not. Furthermore, because of the different settings, \nrs{} consider nonces while \gkp{} consider locks.

\section{Lock-based Authenticated Encryption}
To evaluate the security of generic composition using locks, we define a new security primitive: the lock-based Authenticated Encryption scheme, or lAE scheme for short. This lAE is similar to the nAE from \nrs{}, but it uses locks instead of nonces. Another difference is that it does not use associated data (AD). We will evaluate the security in a multi-user setting where encryption keys are used once.

\subsection{lAE}
A lAE scheme is defined by a tuple $(\text{AE.enc},\text{AE.dec})$. Deterministic algorithm AE.enc takes three inputs $(\keyinstance,\lockinstance,\messageinstance)$ and outputs a value \ciphertextinstance in \ciphertextinstance, where the length of \ciphertextinstance{} only depends on the lengths of \keyinstance, \lockinstance{} and \messageinstance. If, and only if, $(\keyinstance,\lockinstance,\messageinstance)$ is not in $\keyspace \times \lockspace \times \messagespace$, \ciphertextinstance{} will be \invalid. Deterministic algorithm AE.dec takes three inputs $(\keyinstance,\lockinstance,\ciphertextinstance)$ and outputs a value \messageinstance. Both AE.enc and AE.dec are required to satisfy correctness (if AE.enc$(\keyinstance,\lockinstance,\messageinstance)$ $= \ciphertextinstance \neq \invalid$, then AE.dec$(\keyinstance,\lockinstance,\ciphertextinstance)$ = \messageinstance) and tidiness (if AE.dec$(\keyinstance,\lockinstance,\ciphertextinstance)$ $= \messageinstance \neq \invalid$, then AE.enc$(\keyinstance,\lockinstance,\messageinstance)$ = \ciphertextinstance).

\subsection{lAE Security Model} \label{sec: lAE security model}
The security of the lAE is defined as 
\begin{align*} 
    \text{\advantage{\adversary,\users}{lAE} = \probabilityblock{lAE-IND-\$-AE}{\adversary,\users}{0}{1}}
\end{align*}
where lAE-IND-\$-AE is in Figure \ref{fig: lAE-IND game}.
\begin{figure}
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} lAE-IND-\$-AE$^{b}_{\adversary,\users}$ }]{
        L \result \emptyset\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace\\
        \t C_\user \result \invalid\\
        b' \result \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=5,linenumbering,head={\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            \ciphertextinstance \result \text{AE.enc}(\keyinstance_\user,\lockinstance_\user,\messageinstance)\\
            \pcif b = 1 \wedge \ciphertextinstance \neq \invalid: \\
            \t \ciphertextinstance \sample \{0,1\}^{\abs{\ciphertextinstance}}\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=14,linenumbering,head={\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcif C_\user = \invalid: \pcreturn \invalid\\
            \pcif \ciphertextinstance = C_\user: \pcreturn \invalid\\
            \messageinstance \result \text{AE.dec}(\keyinstance_\user,\lockinstance_\user,\ciphertextinstance)\\
            \pcif b = 1 : \messageinstance \result \invalid\\
            \pcreturn \messageinstance
        }
    \end{pchstack}
    \caption{lAE-IND-\$-AE game, adversary{} has access to oracles Oenc and Odec.}
    \label{fig: lAE-IND game}
\end{figure}
We consider multiple users who use their keys once. Consequently, the user is only allowed one encryption query. We allow decryption queries of a user only after an encryption has been made. On decryption, we use a function that always returns \invalid{}. This is to model that the adversary can not forge a valid ciphertext. The idea behind the resulting security game is explained below.

\paragraph{Multiple users}
Line 1 loops over all the users to initialize them with a random key in line 2 and an invalid ciphertext in line 3. Whenever the adversary calls one of the oracles Oenc or Odec, it has to specify user $j$.

\paragraph{Locks}
Line 0 initializes the set of all used locks to the empty set. Locks are not allowed to repeat, if the lock is in the set of used locks we return \invalid{} on line 7. If this check passes, we add the lock to the sets of used locks in line 8 and bind it to the user in line 9. Note that locks may be added to the set of used locks even if they are never used to encrypt a valid message.

\paragraph{One-time use keys}
The variable $C_\user$ is used to prevent multiple encryptions per user. We do not use set notation, as we can never have multiple ciphertexts related to one user. In line 3, we set $C_\user$ to be undefined, if the ciphertext is defined in line 6, we return \invalid. In line 13, the newly computed ciphertext is bound to $C_\user$. If the encryption is invalid, $C_\user$ will stay undefined, this leads to the adversary being able to call Oenc twice on a single user. This will however not give the adversary an advantage as the values for which AE.enc returns \invalid{} are known. If the user has made no valid encryption yet and thus $C_\user$ is undefined, decryption is not allowed and we return \invalid{} on line 15.

\paragraph{Preventing trivial distinctions}
Line 16 prevents trivial distinctions. If the ciphertext given to Odec is allowed to be the same as the ciphertext returned by Oenc, it would be trivial to distinguish the real and ideal world. This is because, when presented with this ciphertext, the user would return \invalid{} in the ideal world while it would return the original message in the real world. To prevent this trivial distinction, the user returns \invalid{} in the real world as well when presented with the ciphertext it computed.

\paragraph{Encryption and decryption}
If the given arguments are valid, and we are in the real world, line 10 encrypts the message, and line 17 decrypts the message.

\paragraph{Implementation of \$}
On encryption, whenever AE returns \invalid{}, the random function should return \invalid{} as well. Therefore, the random function is only called if $b$ = 1 and AE.enc does not return \invalid. If this check in line 11 passes, the random function lazily samples a string uniformly at random with the length of the ciphertext. This random string is bound to the ciphertext in line 12. On decryption, the ideal world always returns \invalid{}.

\section{Composition}
In this section, we discuss how we can construct a safe lAE. Similarly to \gkp{} and \nrs{} we will look at compositions combining a deterministic encryption primitive and MAC primitive. First, we write down the definitions of these two primitives, then we will look at how we can combine the two and which security bounds we can expect.

\subsection{Used Primitives}
\paragraph{lE}
A lock-based encryption scheme, lE for short, is defined by a tuple $(\text{E.enc},\text{E.dec})$. Deterministic algorithm E.enc takes three inputs $(\keyinstance,\lockinstance,\messageinstance)$ and outputs a value \ciphertextinstance in \ciphertextinstance, the length of \ciphertextinstance{} only depends on the lengths of \keyinstance, \lockinstance{} and \messageinstance. If, and only if, $(\keyinstance,\lockinstance,\messageinstance)$ is not in $\keyspace \times \lockspace \times \messagespace$, \ciphertextinstance{} will be \invalid. Deterministic algorithm E.dec takes three inputs $(\keyinstance,\lockinstance,\ciphertextinstance)$ and outputs a value \messageinstance. Both E.enc and E.dec are required to satisfy correctness (if E.enc$(\keyinstance,\lockinstance,\messageinstance)$ $= \ciphertextinstance \neq \invalid$, then E.dec$(\keyinstance,\lockinstance,\ciphertextinstance)$ = \messageinstance) and tidiness (if E.dec$(\keyinstance,\lockinstance,\ciphertextinstance)$ $= \messageinstance \neq \invalid$, then E.enc$(\keyinstance,\lockinstance,\messageinstance)$ = \ciphertextinstance).

\paragraph{lE security}
The security of a lE is defined as 
\begin{align*} 
    \text{\advantage{\adversary,\users}{lE} = \probabilityblock{lE-IND-\$-CPA}{\adversary,\users}{0}{1}}
\end{align*}
where lE-IND-\$-CPA is in Figure \ref{fig: lE-IND game}. The user is only allowed one encryption query and decryption queries are only allowed after the encryption. Locks may not repeat between users.
    \begin{figure}
        \begin{pchstack}[boxed,center,space=0.5cm]
            \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} lE-IND-\$-CPA$^{b}_{\adversary,\users}$ }]{
            L \result \emptyset\\
            \pcfor \user \in [1..\users]:\\
            \t \keyinstance{}_\user \sample \keyspace\\
            \t C_\user \result \invalid\\
            b' \result \adversary\\
            \pcreturn b'
            }
            \pseudocode[lnstart=5,linenumbering,head={\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
                \pcif C_\user \neq \invalid: \pcreturn \invalid\\
                \pcif \lockinstance \in L: \pcreturn \invalid\\
                L \result L \cup \{\lockinstance\}\\
                \lockinstance{}_\user \result \lockinstance\\
                \ciphertextinstance \result \text{E.enc}(\keyinstance{}_\user,\lockinstance{}_\user,\messageinstance)\\
                \pcif b = 1 \wedge \ciphertextinstance \neq \invalid: \\
                \t \ciphertextinstance \sample \{0,1\}^{\abs{\ciphertextinstance}}\\
                C_\user \result \ciphertextinstance\\
                \pcreturn \ciphertextinstance
            }
        \end{pchstack}
    \caption{lE-IND-\$-CPA game, \adversary{} has access to oracle Oenc.}
    \label{fig: lE-IND game}
    \end{figure}
    
\paragraph{lMAC}
A lock-based MAC is defined by a deterministic algorithm M.mac that takes a fixed length \keyinstance{} in \keyspace{}, a fixed length \lockinstance{} in \lockspace{} and a variable-length message \messageinstance{} in \messagespace{} and outputs either a n-bit length string in \tagspace{} we call tag \taginstance, or \invalid. If, and only if, $(\keyinstance,\lockinstance,\messageinstance)$ is not in $\keyspace \times \lockspace \times \messagespace$, \taginstance{} will be \invalid. The tag space \tagspace{} consists of all valid tags.

\paragraph{lMAC security}
The security of a lock bases, PRF secure MAC is defined as \begin{align*} 
    \text{\advantage{F,\adversary,\users}{lMAC} = \probabilityblock{lMAC-PRF}{\adversary,\users}{0}{1}}
   \end{align*}
where lMAC-PRF is in Figure \ref{fig: lMAC-PRF game}. Every user is only allowed one MAC query and verification queries are only allowed after the MAC query. Locks may not repeat between users. In contrast to the MAC-PRF from \nrs{}, a verification oracle is needed as we only allow one Omac query per user. In the real world, Ovrf will check similar constraints as the Odec from Figure \ref{fig: lAE-IND game}. If an Omac query has been made for the given user, and the given message-tag pair is not the result of this query, then the pair is verified. In the ideal world, uniformly random function $tag$ is used instead of the lMAC. To define this function we write $\mathit{Func}(\keyspace \times \lockspace \times \messagespace,\tagspace)$ to denote the set of all functions from key space \keyspace, lock space \lockspace{} and message space \messagespace{} to tag space \tagspace. We need to define this function specifically as we want the tags resulting from computations in oracle Ovrf to match with those in oracle Omac. When the input of $tag$ is outside its domain, it will return \invalid.
    \begin{figure}
        \centering
        \begin{pchstack}[boxed,center,space=0.5cm]
            \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} lMAC-PRF$^{b}_{\adversary,\users}$ }]{
                L \result \emptyset\\
                \pcif b = 1: \\
                \t tag \sample \mathit{Func}(\keyspace \times \lockspace \times \messagespace, \tagspace)\\
                \pcfor \user \in [1..N]:\\
                \t \keyinstance_\user \sample \keyspace\\
                \t T_\user \result \invalid\\
                b' \result A\\
                \pcreturn b'
            }
            \pseudocode[lnstart=7,linenumbering,head={\textbf{Oracle} Omac$(\user,\lockinstance,\messageinstance)$}]{
                \pcif T_\user \neq \invalid: \pcreturn \invalid\\
                \pcif \lockinstance \in L: \pcreturn \invalid\\
                L \result L \cup \{\lockinstance\}\\
                \lockinstance_\user \result \lockinstance\\
                \taginstance \leftarrow \text{M.mac}(\keyinstance_\user,\lockinstance_\user,\messageinstance)\\
                \pcif b = 1 \wedge \taginstance \neq \invalid: \\
                \t \taginstance \result tag(\keyinstance_\user,\lockinstance_\user,\messageinstance)\\
                T_\user \result (\messageinstance,\taginstance)\\
                \pcreturn \taginstance
            }
            \pseudocode[lnstart=14,linenumbering,head={\textbf{Oracle} Ovrf$(\user,\messageinstance,\taginstance)$}]{
                \pcif T_\user = \invalid: \pcreturn \invalid\\
                \pcif (\messageinstance,\taginstance) = T_\user : \pcreturn \invalid \\
                \taginstance' \leftarrow \text{M.mac}(\keyinstance_\user,\lockinstance_\user,\messageinstance)\\
                \pcif b = 1 : \\
                \t \taginstance' \leftarrow tag(\keyinstance_\user,\lockinstance_\user,\messageinstance)\\
                \pcif \taginstance = \taginstance' \\
                \t \pcreturn \codetrue\\
                \pcreturn \codefalse
            }
        \end{pchstack}
        \caption{lMAC-PRF game, \adversary{} has access to oracle Omac.}
        \label{fig: lMAC-PRF game}
    \end{figure}

\subsection{Composition}
Following \nrs{}, three ways to construct this lAE are of interest, namely, the ones related to schemes N1, N2 and N3. All three schemes, adjusted to our setting, are in Figure \ref{fig: N schemes}. \nrs{} consider 17 more schemes but as none of them has proven to be secure we will not consider those in this work. The AE.enc and AE.dec calls corresponding to N1, N2 and N3 are in Figure \ref{fig: N1 calls}, \ref{fig: N2 calls} and \ref{fig: N3 calls} respectively.
\begin{figure}
    \centering
    \includegraphics[scale = 0.4]{images/N-schemes.png}
\caption{Adjusted N schemes from \nrs}
\label{fig: N schemes}
\end{figure}

\begin{figure}
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={AE.enc$(\keyinstance,\lockinstance,\messageinstance)$}]{
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance \\
            \ciphertextinstance' \result \text{E.enc}(\keyinstance{}1,\lockinstance,\messageinstance) \\
            \taginstance \result \text{M.mac}(\keyinstance{}2,\lockinstance,\messageinstance) \\
            \ciphertextinstance \result (\ciphertextinstance',\taginstance)\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=4,linenumbering,head={AE.dec$(\keyinstance,\lockinstance,\ciphertextinstance)$}]{
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance \\
            (\ciphertextinstance',\taginstance) \result \ciphertextinstance \\
            \messageinstance \result \text{E.dec}(\keyinstance{}1,\lockinstance,\ciphertextinstance') \\
            \taginstance' \result \text{M.mac}(\keyinstance{}2,\lockinstance,\messageinstance) \\
            \pcif \taginstance \neq \taginstance' : \messageinstance \result \invalid\\
            \pcreturn \messageinstance
        }
    \end{pchstack}
\caption{AE.enc an AE.dec based on N1}
\label{fig: N1 calls}
\end{figure}

\begin{figure}
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={AE.enc$(\keyinstance,\lockinstance,\messageinstance)$}]{
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance\\
            \ciphertextinstance' \result \text{E.enc}(\keyinstance{}1,\lockinstance,\messageinstance)\\
            \taginstance \result \text{M.mac}(\keyinstance{}2,\lockinstance,\ciphertextinstance')\\
            \ciphertextinstance \result (\ciphertextinstance',\taginstance)\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=4,linenumbering,head={AE.dec$(\keyinstance,\lockinstance,\ciphertextinstance)$}]{
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance\\
            (\ciphertextinstance',\taginstance) \result \ciphertextinstance\\
            \messageinstance \result \text{E.dec}(\keyinstance{}1,\lockinstance,\ciphertextinstance')\\
            \taginstance' \result \text{M.mac}(\keyinstance{}2,\lockinstance,\ciphertextinstance')\\
            \pcif \taginstance \neq \taginstance' : \messageinstance \result \invalid\\
            \pcreturn \messageinstance
        }
    \end{pchstack}
\caption{AE.enc an AE.dec based on N2}
\label{fig: N2 calls}
\end{figure}

\begin{figure}
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={AE.enc$(\keyinstance,\lockinstance,\messageinstance)$}]{
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance\\
            \taginstance \result \text{M.mac}(\keyinstance{}2,\lockinstance,\messageinstance)\\
            \messageinstance' \result \messageinstance \concatinate \taginstance\\
            \ciphertextinstance \result \text{E.enc}(\keyinstance{}1,\lockinstance,\messageinstance')\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=4,linenumbering,head={AE.dec$(\keyinstance,\lockinstance,\ciphertextinstance)$}]{
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance\\
            \messageinstance' \result \text{E.dec}(\keyinstance{}1,\lockinstance,\ciphertextinstance)\\
            (\messageinstance,\taginstance) \result \messageinstance'\\
            \taginstance' \result \text{M.mac}(\keyinstance{}2,\lockinstance,\messageinstance)\\
            \pcif \taginstance \neq \taginstance' : \messageinstance \result \invalid\\
            \pcreturn \messageinstance
        }
    \end{pchstack}
\caption{AE.enc an AE.dec based on N3}
\label{fig: N3 calls}
\end{figure}

\subsection{Security Bounds}
We define the composition secure if there is a tight reduction from breaking the lAE-security of the scheme to breaking the lE-security or the lMAC security of the underlying primitives. More specifically, define it to be secure if we prove the following theorem:

\begin{theorem}
    Let lAE be constructed from lMAC and lE as described in Figure \ref{fig: N1 calls}, \ref{fig: N2 calls} or \ref{fig: N3 calls}. Let ciphertext space \ciphertextspace{} from the lE be a subset of message space \messagespace{} from the lMAC and let lMAC and lE have a shared lock space. Then, for any number of users \users{} and any lAE adversary \adversary{} that poses at most $Q_e$ many Oenc queries, and at most $Q_d$ many Odec queries, there exist a lMAC adversary $B$ and a lE adversary $C$ such that:
    \textnormal{
    \begin{align*}
        \text{\advantage{$A$,\users}{lAE}} \leq \text{\advantage{$B$,\users}{lMAC}} + \text{\advantage{$C$,\users}{lE}} + \frac{Q_d}{2^{\text{n}}},
    \end{align*}
    }
    \hspace{-0,3cm} where \textnormal{n} is the output length of the lMAC in bits. The running time of $B$ is at most that of A plus the time required to run $Q_e$ many \textnormal{E.enc} encapsulations and $Q_d$ many \textnormal{E.dec} decapsulations. The running time of $C$ is at most that of \adversary. Additionally, $B$ makes at most $Q_e$ many Omac queries and at most $Q_d$ many Ovrf queries and $C$ makes at most $Q_e$ many Oenc queries.
\end{theorem}
\noindent
Within this theorem, both $Q_e$ and $Q_d$ refer to the total queries the adversary is allowed to make, not the queries per user. As a result, $Q_e$ is limited by \users.

\section{Security proof} \label{sec: sec prove}
To prove Theorem 1, we prove it separately for N1, N2 and N3. In this section, the full proof of case N1 can be found, as well as the main differences between the three cases. The full proof of cases N2 and N3 can be found in Appendix A.
\paragraph*{N1}
First, we repeat Theorem 1 specifically for N1:
\begin{theorem}
Let lAE be constructed from lMAC and lE as described in Figure \ref{fig: N1 calls}. Let ciphertext space \ciphertextspace{} from the lE be a subset of message space \messagespace{} from the lMAC and let lMAC and lE have a shared lock space. Then, for any number of users \users{} and any lAE adversary \adversary{} that poses at most $Q_e$ many Oenc queries, and at most $Q_d$ many Odec queries, there exist a lMAC adversary $B$ and a lE adversary $C$ such that:
\textnormal{
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}} \leq \text{\advantage{$B$,\users}{lMAC}} + \text{\advantage{$C$,\users}{lE}} + \frac{Q_d}{2^{\text{n}}},
\end{align*}
}
\hspace{-0,3cm} where \textnormal{n} is the output length of the lMAC in bits. The running time of $B$ is at most that of A plus the time required to run $Q_e$ many \textnormal{E.enc} encapsulations and $Q_d$ many \textnormal{E.dec} decapsulations. The running time of $C$ is at most that of \adversary. Additionally, $B$ makes at most $Q_e$ many Omac queries and at most $Q_d$ many Ovrf queries and $C$ makes at most $Q_e$ many Oenc queries.
\end{theorem}
\noindent
Within this theorem, both $Q_e$ and $Q_d$ refer to the total queries the adversary is allowed to make, not the queries per user. As a result, $Q_e$ is limited by \users.
\begin{proof}
To prove this theorem, we start by defining game lAE-N1 in Figure \ref{fig: lAE-N1 game}. This game is the game lAE-IND-\$-AE (Figure \ref{fig: lAE-IND game}), with AE.enc and AE.dec substituted with the N1 algorithms found in Figure \ref{fig: N1 calls}.
\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} lAE-N1$^{b}_{\adversary,\users}$ }]{
        L \result \emptyset\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace\\
        \t C_\user \result \invalid\\
        b' \result \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=5,linenumbering,head={\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            \ciphertextinstance' \result \text{E.enc}(\keyinstance{}1,\lockinstance_j,\messageinstance)\\
            \taginstance \result \text{M.mac}(\keyinstance{}2,\lockinstance_j,\messageinstance)\\
            \ciphertextinstance \result (\ciphertextinstance',\taginstance)\\
            \pcif b = 1 \wedge \ciphertextinstance \neq \invalid: \\
            \t \ciphertextinstance \sample \{0,1\}^{\abs{\ciphertextinstance}}\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=17,linenumbering,head={\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcif C_\user = \invalid: \pcreturn \invalid\\
            \pcif \ciphertextinstance = C_\user: \pcreturn \invalid\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            (\ciphertextinstance',\taginstance) \result \ciphertextinstance\\
            \messageinstance \result \text{E.dec}(\keyinstance{}1,\lockinstance_j,\ciphertextinstance')\\
            \taginstance' \result \text{M.mac}(\keyinstance{}2,\lockinstance_j,\messageinstance)\\
            \pcif \taginstance \neq \taginstance' : \messageinstance \result \invalid\\
            \pcif b = 1 : \messageinstance \result \invalid\\
            \pcreturn \messageinstance
        }
    \end{pchstack}
    \caption{lAE-N1 game, adversary{} has access to oracles Oenc and Odec.}
    \label{fig: lAE-N1 game}
\end{figure}

\noindent By definition, this gives us
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    =
    \text{Pr}[\text{lAE-N1}_{\text{\adversary,\users}}^0 =0]
    -
    \text{Pr}[\text{lAE-N1}_{\text{\adversary,\users}}^1 =0].
\end{align*}
Next, we define game N1-switch-1 in Figure \ref{fig: N1-switch-1 game}. The only difference between this game and game lAE-N1$^0$ is the fact that N1-switch-1 uses the uniformly random function $tag$, instead of the lMAC. To define this function we write $\mathit{Func}(\keyspace \times \lockspace \times \messagespace,\tagspace)$ to denote the set of all functions from the key space of the MAC \keyspace, the shared lock space \lockspace{} and message space \messagespace{} to the tag space \tagspace. We define this function specifically as we want the tags resulting from computations in oracle Oenc to match with those in oracle Odec. When the input of $tag$ is outside its domain, it will return \invalid.

\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} N1-switch-1$_{\adversary,\users}$ }]{
        L \result \emptyset\\
        tag \sample \mathit{Func}(\keyspace_{mac}\times \lockspace \times \messagespace, \tagspace)\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace\\
        \t C_\user \result \invalid\\
        b' \result \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=6,linenumbering,head={\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            \ciphertextinstance' \result \text{E.enc}(\keyinstance{}1,\lockinstance_j,\messageinstance)\\
            \taginstance \result tag(\keyinstance{}2,\lockinstance_j,\messageinstance)\\
            \ciphertextinstance \result (\ciphertextinstance',\taginstance)\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=16,linenumbering,head={\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcif C_\user = \invalid: \pcreturn \invalid\\
            \pcif \ciphertextinstance = C_\user: \pcreturn \invalid\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            (\ciphertextinstance',\taginstance) \result \ciphertextinstance\\
            \messageinstance \result \text{E.dec}(\keyinstance{}1,\lockinstance_j,\ciphertextinstance')\\
            \taginstance' \result tag(\keyinstance{}2,\lockinstance_j,\messageinstance)\\
            \pcif \taginstance \neq \taginstance' : \messageinstance \result \invalid\\
            \pcreturn \messageinstance
        }
    \end{pchstack}
    \caption{N1-switch-1, adversary{} has access to oracles Oenc and Odec. 
    Key space $\keyspace_{mac}$ is the key space from M.mac. Lines 13 and 22 are different compared to lAE-N1$^0$, additionally, lines 14, 15 and 25 from lAE-N1 are removed.}
    \label{fig: N1-switch-1 game}
\end{figure}

\noindent
Using this game, we expand the probability:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &=
    \text{Pr}[\text{lAE-N1}_{\text{\adversary,\users}}^0 =0]
    -
    \text{Pr}[\text{N1-switch-1}_{\text{\adversary,\users}} =0]
    \\&   + \text{Pr}[\text{N1-switch-1}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N1}_{\text{\adversary,\users}}^1 =0].
\end{align*}
Next, we can rewrite $\text{Pr}[\text{lAE-N1}_{\text{\adversary,\users}} =0] - \text{Pr}[\text{N1-switch-1}_{\text{\adversary,\users}} =0]$ into a lMAC advantage. To do so, we define adversary $B$ against lMAC in Figure \ref{fig: adversary B N1}. This adversary is playing the game lMAC-PRF (Figure \ref{fig: lMAC-PRF game}), and has access to \adversary. 
\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Adverary} $B$}]{
        L \result \emptyset\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace_{enc}\\
        \t C_\user \result \invalid\\
        b' \result \textbf{run } \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=5,linenumbering,head={\text{if \adversary{} calls }\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            \ciphertextinstance' \result \text{E.enc}(\keyinstance_j,\lockinstance_j,\messageinstance)\\
            \taginstance \result \text{Omac}(\user,\lockinstance_j,\messageinstance)\\
            \ciphertextinstance \result (\ciphertextinstance',\taginstance)\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=14,linenumbering,head={\text{if \adversary{} calls }\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcif C_\user = \invalid: \pcreturn \invalid\\
            \pcif \ciphertextinstance = C_\user: \pcreturn \invalid\\
            (\ciphertextinstance',\taginstance) \result \ciphertextinstance\\
            \messageinstance \result \text{E.dec}(\keyinstance{}_j,\lockinstance_j,\ciphertextinstance')\\
            passed \result \text{Ovrf}(\user,\messageinstance,\taginstance')\\
            \pcif \neg passed : \messageinstance \result \invalid\\
            \pcreturn \messageinstance
        }
    \end{pchstack}
    \caption{Adversary $B$ has access to \adversary{} and oracles Omac and Ovrf. Key space $\keyspace_{enc}$ is the key space from E.enc.}
    \label{fig: adversary B N1}
\end{figure}

\noindent
The runtime of $B$ is that of $A$. For every Oenc query \adversary{} makes, $B$ computes E.enc once and calls Omac once. For every Odec query \adversary{} makes, $B$ computes E.dec once and calls Ovrf once. Note that, alternatively, $B$ could return 0 if $passed$ is \codetrue{} to avoid having to do E.dec computations. To increase consistency with the other two cases, these computations are still made. We can see that $\text{Pr}[\text{lMAC-PRF}_{\text{$B$,\users}}^0 =0]=\text{Pr}[\text{lAE-N1}_{\text{\adversary,\users}}^0 =0]$ as $B$ perfectly simulates game lAE-N1$^0$ when its own $b$ is 0. In addition, $\text{Pr}[\text{lMAC-PRF}_{\text{$B$,\users}}^1 =0]=\text{Pr}[\text{N1-switch-1}_{\text{\adversary,\users}} =0]$ as $B$ perfectly simulates game N1-switch-1 whenever its own $b$ is 1. As a result, we can rewrite our advantage to:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &=
    \text{Pr}[\text{lAE-N1}_{\text{\adversary,\users}}^0 =0]
    -
    \text{Pr}[\text{N1-switch-1}_{\text{\adversary,\users}} =0]
    \\&  + \text{Pr}[\text{N1-switch-1}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N1}_{\text{\adversary,\users}}^1 =0]
    \\& =
    \text{Pr}[\text{lMAC-PRF}_{\text{$B$,\users}}^0 =0]
    -
    \text{Pr}[\text{lMAC-PRF}_{\text{$B$,\users}}^1 =0]
    \\&  + \text{Pr}[\text{N1-switch-1}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N1}_{\text{\adversary,\users}}^1 =0]
    \\& = \text{\advantage{$B$,\users}{lMAC}}
    + \text{Pr}[\text{N1-switch-1}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N1}_{\text{\adversary,\users}}^1 =0].
\end{align*}
To expand our advantage again, we define game N1-switch-2 in Figure \ref{fig: N1-switch-2 game}. Apart from the Odec query, this game is equivalent to the first switch game. Although, the Odec oracle from N1-switch-2 always returns \invalid{}, it is written down more elaborately to include the event $bad$. This event is added to support a well-known proof tactic \cite{EC:BelRog06}. When expanded again, our advantage becomes:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &=
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{Pr}[\text{N1-switch-1}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{N1-switch-2}_{\text{\adversary,\users}} =0]
    \\& +
    \text{Pr}[\text{N1-switch-2}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N1}_{\text{\adversary,\users}}^1 =0].
\end{align*}
\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} N1-switch-2$_{\adversary,\users}$ }]{
        L \result \emptyset\\
        tag \sample \mathit{Func}(\keyspace_{mac}\times \lockspace \times \messagespace,\tagspace)\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace\\
        \t C_\user \result \invalid\\
        b' \result \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=6,linenumbering,head={\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            \ciphertextinstance' \result \text{E.enc}(\keyinstance{}1,\lockinstance_j,\messageinstance)\\
            \taginstance \result tag(\keyinstance{}2,\lockinstance_j,\messageinstance)\\
            \ciphertextinstance \result (\ciphertextinstance',\taginstance)\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=16,linenumbering,head={\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcif C_\user = \invalid: \pcreturn \invalid\\
            \pcif \ciphertextinstance = C_\user: \pcreturn \invalid\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            (\ciphertextinstance',\taginstance) \result \ciphertextinstance\\
            \messageinstance \result \text{E.dec}(\keyinstance{}1,\lockinstance_j,\ciphertextinstance')\\
            \taginstance' \result tag(\keyinstance{}2,\lockinstance_j,\messageinstance)\\
            \pcif \taginstance \neq \taginstance' : \messageinstance \result \invalid\\
            \pcelse: \\
            \t bad \result \codetrue\\
            \t \messageinstance \result \invalid\\
            \pcreturn \messageinstance
        }
    \end{pchstack}
    \caption{N1-switch-2 game, adversary{} has access to oracles Oenc and Odec. Key space $\keyspace_{mac}$ is the key space from M.mac. Lines 24-26 are different compared to N1-switch-1.}
    \label{fig: N1-switch-2 game}
\end{figure}
\noindent
As N1-switch-1 and N1-switch-2 are so called identical-until-$bad$ \cite{EC:BelRog06}, meaning they are equivalent as long as the event $bad$ is not set to \codetrue, we know:
\begin{align*}
    \text{Pr}[\text{N1-switch-1}_{\text{\adversary,\users}} =0]-\text{Pr}[\text{N1-switch-2}_{\text{\adversary,\users}} =0] \leq \text{Pr}[bad=\codetrue].
\end{align*}
As $bad$ is set to \codetrue{} if, and only if, \taginstance=\taginstance$'$, we can state $\text{Pr}[bad=\codetrue] = \text{Pr}[\taginstance=\taginstance']$. The adversary needs to provide tag \taginstance{} and ciphertext \ciphertextinstance$'$, where ciphertext \ciphertextinstance$'$ leads to a message \messageinstance{} that is used as input to the $tag$ function. The provided tag-ciphertext pair may not be the result of the encryption query corresponding to the provided user. Combined with the tidiness of the encryption, it is ensured that, for any sensible adversarial query, the message \messageinstance{} cannot be the message that is encrypted for the provided user. This is because if \messageinstance{} would be the encrypted message, the correct tag cannot be provided and thus no information can be gained with the query. Consequently, \taginstance{} and \taginstance$'$ are only equal when the adversary can guess the output of $tag$ for a message that is not encrypted for the provided user. The function $tag$ is uniformly random so, with every fresh ciphertext, the probability that the guessed \taginstance{} is equal to the correct \taginstance$'$ is $\frac{1}{2^{\text{n}}}$. Summed over at most $Q_d$ Odec queries we get $\text{Pr}[\taginstance=\taginstance'] = \text{Pr}[bad=\codetrue] \leq \frac{Q_d}{2^{\text{n}}}$ and thus, we can use $\text{Pr}[\text{N2-switch-1}_{\text{\adversary,\users}} =0]-\text{Pr}[\text{N1-switch-2}_{\text{\adversary,\users}} =0] \leq \text{Pr}[bad=\codetrue] \leq \frac{Q_d}{2^{\text{n}}}$ to obtain:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &\leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{Pr}[\text{N1-switch-2}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N2}_{\text{\adversary,\users}}^1 =0]
    +
    \frac{Q_d}{2^{\text{n}}}.
\end{align*}
We define game N1-switch-3 in Figure \ref{fig: N1-switch-3 game} to expand our advantage one last time. Switch game 3 is equivalent to switch game 2 but always returns lazily sampled random bits when the outcome of E.enc is valid. It might seem like there is a difference as \taginstance{} can no longer become \invalid. This is not the case as, due to the chosen input spaces of $tag$, $tag$ can only return \invalid{} whenever \ciphertextinstance$'$ is already \invalid. As a result, $tag$ will never influence whether or not \ciphertextinstance{} on line 12 is \invalid. We also simplify Odec as we no longer need the event $bad$. We use this game to expand our advantage to:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &\leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{Pr}[\text{N1-switch-2}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{N1-switch-3}_{\text{\adversary,\users}} =0]
    \\& +
    \text{Pr}[\text{N1-switch-3}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N1}_{\text{\adversary,\users}}^1 =0]
    +
    \frac{Q_d}{2^{\text{n}}}.
\end{align*}

\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} N1-switch-3$_{\adversary,\users}$ }]{
        L \result \emptyset\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace_{enc}\\
        \t C_\user \result \invalid\\
        b' \result \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=5,linenumbering,head={\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            \ciphertextinstance' \result \text{E.enc}(\keyinstance{}j,\lockinstance_j,\messageinstance)\\
            \taginstance \sample \{0,1\}^{\text{n}}\\
            \ciphertextinstance \result (\ciphertextinstance',\taginstance)\\
            \pcif \ciphertextinstance \neq \invalid: \\
            \t \ciphertextinstance \sample \{0,1\}^{\abs{\ciphertextinstance}}\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=17,linenumbering,head={\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcreturn \invalid
        }
    \end{pchstack}
    \caption{N1-switch-3 game, adversary{} has access to oracles Oenc and Odec. Key space $\keyspace_{enc}$ is the key space from E.enc. Lines 14 and 15 are different compared to N1-switch-2, and Odec is simplified.}
    \label{fig: N1-switch-3 game}
\end{figure}
\noindent
$\text{Pr}[\text{N1-switch-3}_{\text{\adversary,\users}} =0]$ and $\text{Pr}[\text{lAE-N1}_{\text{\adversary,\users}}^1 =0]$ are equivalent by definition, giving:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &\leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{Pr}[\text{N1-switch-2}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{N1-switch-3}_{\text{\adversary,\users}} =0]
    +
    \frac{Q_d}{2^{\text{n}}}.
\end{align*}
Next, we can rewrite $\text{Pr}[\text{N1-switch-2}_{\text{\adversary,\users}} =0] - \text{Pr}[\text{N1-switch-3}_{\text{\adversary,\users}} =0]$ into a lE advantage. To do so, we define adversary $C$ against lE in Figure \ref{fig: adversary c N1}. This adversary is playing game lE-IND-\$-CPA (Figure \ref{fig: lE-IND game}), and has access to \adversary. 
\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Adverary} $C$}]{
        L \result \emptyset\\
        \pcfor \user \in [1..N]:\\
        \t C_\user \result \invalid\\
        b' \result \textbf{run } \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=4,linenumbering,head={\text{if \adversary{} calls }\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            \ciphertextinstance' \result \text{Oenc}(\user,\lockinstance_j,\messageinstance)\\
            \taginstance \sample \{0,1\}^{\text{n}}\\
            \ciphertextinstance \result (\ciphertextinstance',\taginstance)\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=13,linenumbering,head={\text{if \adversary{} calls }\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcreturn \invalid
        }
    \end{pchstack}
    \caption{Adversary $C$ has access to \adversary{} and oracle Oenc. Note the Oenc in line 9 refers to the encryption oracle Oenc that $C$ has access to, not the oracle Oenc $A$ has access to.}
    \label{fig: adversary c N1}
\end{figure}
\noindent
The runtime of $C$ is that of $A$. For every Oenc query $A$ makes, $C$ makes one Oenc query. We can see that $\text{Pr}[\text{N1-switch-2}_{\text{\adversary,\users}} =0] = \text{Pr}[\text{lE-IND-\$-CPA}_{\text{$C$,\users}}^0 =0]$ as $C$ perfectly simulates N1-switch-2 when its own $b$ is 0. When its own $b$ is 1, $C$ perfectly simulates N1-switch-3 giving $\text{Pr}[\text{N1-switch-3}_{\text{\adversary,\users}} =0] = \text{Pr}[\text{lE-IND-\$-CPA}_{\text{$C$,\users}}^1 =0]$. This leads us to:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &\leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{Pr}[\text{N1-switch-2}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{N1-switch-3}_{\text{\adversary,\users}} =0]
    +
    \frac{Q_d}{2^{\text{n}}}
    \\& \leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{Pr}[\text{lE-IND-\$-CPA}_{\text{$C$,\users}}^0 =0]
    -
    \text{Pr}[\text{lE-IND-\$-CPA}_{\text{$C$,\users}}^1 =0]
    +
    \frac{Q_d}{2^{\text{n}}}
    \\& \leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{\advantage{$C$,\users}{lE}}
    +
    \frac{Q_d}{2^{\text{n}}} .
\end{align*}
Thus proving:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    \leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{\advantage{$C$,\users}{lE}}
    +
    \frac{Q_d}{2^{\text{n}}}.\tag*{\qedhere}
\end{align*}
\end{proof}
\paragraph*{N2 and N3}
Structurally, the proofs of all three cases are identical. For each case, the games used in the proof, as well as the adversaries, are adjusted to the AE.enc and AE.dec corresponding to the N-scheme. As a result, they differ in the three lines generating \ciphertextinstance{} and in the three lines generating \taginstance'. As an example, the games lAE-N1 in Figure \ref*{fig: lAE-N1 game}, lAE-N2 in Figure \ref*{fig: lAE-N2 game} and lAE-N3 in Figure \ref*{fig: lAE-N3 game} only differ on lines 11 to 13 and lines 21 to 23. In addition, the input spaces to some functions are different to facilitate this change. The argument leading to $\text{Pr}[bad=\codetrue] \leq \frac{Q_d}{2^{\text{n}}}$ is different for the three cases as the tags are generated differently. To highlight this difference, the argument is put in between horizontal bars in the proofs for N2 and N3. The full proofs of these two cases are in Appendix \ref{full_proofs}.

\section{Use Cases}
In this section, we will look at some use cases for the lAE. The most prominent use case is hybrid encryption as the idea of locks originated in this setting. In addition to this, the primitive might be useful whenever a new key is generated often as this will increase the number of ephemeral keys used and hence the chance of ephemeral key collisions. Below, we describe how the lAE can be used as a building block for hybrid encryption. We also give some direction on how it might be used in different settings.

\subsection{Hybrid Encryption}
To implement public-key encryption, a hybrid paradigm first, formalized by Cramer and Shoup \cite{CraSho03}, is typically followed: To encrypt a message, an ephemeral key is generated using a randomized key encapsulation mechanism (KEM). This key is then used to encrypt the message using a deterministic data encapsulation mechanism (DEM). Both the KEM and DEM output their own ciphertexts, which are concatenated to form the public-key encryption ciphertext. The benefits of hybrid encryption are a separation of both primitives, as well as the possibility of variable-length messages, which can be lacking in other public-key encryption paradigms. GKP show us how the lAE can be used in hybrid encryption. The KEM, as usual, generates an ephemeral key and encapsulates this key to create the first part of the ciphertext. Afterward, the lAE uses this encapsulation as a lock, together with the ephemeral key and the message, to instantiate the DEM. GKP prove this construction to be secure whenever locks do not repeat. Our lAE does not need to be altered in order to be used in this setting as the ephemeral key is only used once.

\subsection{Other Use Cases}
Whenever an authenticated encryption primitive has many users that use a key only once, using our lAE may decrease the degradation of security bounds. Even when the primitive uses the same key multiple times, using lAE may still decrease the degradation of security bounds whenever the key is changed often. One example of such a use case is the Messaging Layer Security protocol \cite{rfc9420}. Generating a new key is necessary in this protocol whenever a member enters or leaves the group to ensure only current group members can read messages. In addition to this, new keys may be generated more often, depending on the implementation of the protocol. In cases like this, where the key is used multiple times, the lAE primitive most likely needs to be slightly altered. Section \ref{sec: open problems} describes this alteration further. 

\section{Related Work} \label{sec: related work}
As mentioned before, the generic composition of authenticated encryption was first studied by Bellare and Namprempre \cite{AC:BelNam00}. The three most common composition modes encrypt-and-MAC, encrypt-then-MAC and MAC-then-encrypt were introduced and evaluated using a probabilistic encryption block. They find generic construction to be secure when using the encrypt-then-MAC method. NRS further investigated these modes of composition and state that the type of encryption primitive used, as well as the required end result, influences which compositions are secure. They investigated ways to compose a nonce-based authenticated encryption scheme. Using IV-based encryption and a PRF secure MAC, 8 schemes are proven secure. Using nonce-based encryption and a PRF secure MAC, 3 schemes, related to encrypt-and-MAC, encrypt-then-MAC and MAC-then-encrypt, are proven secure.
\\\\
The study of symmetric cryptographic primitives is usually done in a single-user setting, where one user who uses one key is considered. In reality, most systems have multiple users using their own keys. To account for this, the notion of multi-user security, where one considers multiple users all generating their own keys, was first introduced by Bellare, Boldyreva and Micali \cite{EC:BelBolMic00}. Security bounds found in a single-user setting often degrade in a multi-user setting as noted by Biham \cite{BIHAM2002117}. He finds that, in a multi-user setting, the strength of a cipher can not exceed the square root of the key size. To compensate for this degradation, one can expand the size of the key. This might not always be an option and therefore, GKP introduce locks as an alternative to key expansion. They show how ephemeral key collisions in a multi-user setting can lead to insecurities, as well as how one can augment security primitives with locks to prevent these insecurities. Afterwards, a composition of an augmented MAC and an augmented DEM is shown which is suitable for hybrid encryption.
\\\\
Next, we will discuss some work relating to the generic construction of lAE, open problems relating to this work can be found in Section \ref{sec: open problems}. As an alternative to generic composition, authenticated encryption can also be composed non-generically. In this fashion, Rogaway, Bellare and Black propose OCB as a non-generic authenticated encryption construction \cite{CCS:RBBK01}. OCB is highly parallelizable and is cheaper in computation compared to generic construction. In the basic form, it cannot take in associated data but an extension has been given to allow for this. It is proven secure whenever the underlying block cipher is secure. Likewise, McGrew and Viega propose Galois/Counter Mode, GCM, as a non-generic authenticated encryption construction \cite{mcgrew2004security}. It is a highly efficient mode of operation, also due to its parallelizability. GCM incorporates counter mode using an even-length block cipher and supports the usage of associated data. In addition to authenticated encryption, it can also be used as a standalone MAC function. In a multi-user setting, some attempts to improve bounds were made based on randomization (for example randomized GCM \cite{C:BelTac16}). However, it still suffered from a high key collision probability when the number of users grew large. Many more non-generic authenticated encryption schemes exist, but OCB and GCM are the most widely used ones.
\\\\
Although OCB and GCM are most widely used, more and more new schemes are based on the sponge construction, first introduced by Bertoni et al \cite{bertoni2007sponge}. To construct authenticated encryption from a sponge, Bertoni et al. \cite{SAC:BDPV11} first introduced the duplex construction and implemented it using a sponge. Authenticated encryption schemes like SpongeWrap \cite{SAC:BDPV11}, introduced in the same paper introducing the duplex, and Ascon, first introduced by Dobraunig et al. \cite{dobraunig2014ascon}, are based on this duplex construction. Both of these modes allow associated data and have similar advantages and limitations. Compared to more traditional block ciphers, like OCB and GCM, that use a block cipher, sponge-based authenticated encryption only requires a permutation. They are also more efficient compared to generic construction as they do not require the tag and ciphertext to be computed separately. As a limitation, both constructions cannot be fully parallelized. To improve the security of sponge-based authenticated encryption in a multi-user setting, different initialization methods can be used. A comprehensive overview of the security implications of these different methods is given by Dobraunig and Mennink \cite{dobraunig2024generalized}.
\\\\
A similar construction to locks, called ``id", is used to construct a sponge-based PRF \cite{EPRINT:BhaBhaNan22} and to construct a PRF out of a permutation \cite{EPRINT:kirby}. Just like the lock, this id is bound to the user to prevent degradation of security bounds due to user key collisions. The first construction assumes the id to be unique while the second allows the id to be shared between multiple users. The security bounds of both constructions are proven to have little degradation in a multi-user setting when the underlying primitives are ideal.


\section{Conclusion} \label{sec: open problems}
In this thesis, we studied the security of generic composition of authenticated encryption using locks. To do this, we first defined a new security primitive, named lock-based authenticated encryption. Three different ways in which we can compose this new primitive using a lock-based encryption primitive and a lock-based MAC function were considered, namely encrypt-and-MAC, encrypt-then-MAC and MAC-then-encrypt. All three of these compositions were proven secure, whenever the underlying primitives are secure. Additionally, we explored some use cases of our new primitive. Most specifically, we explained how lock-based authenticated encryption can be used to instantiate a DEM in hybrid encryption. The results of this work have some open problems we will discuss below. Wherever possible we will also give directions on what needs to be done in order to investigate these problems further.

\paragraph*{Other N schemes}
NRS find 20 possible N-schemes, of which 3 are proven secure. In this thesis, only the N-schemes that are alterations of the ones proven secure by NRS were evaluated. To more thoroughly investigate the security of generic lAE compositions, the other N-schemes should also be proven secure or insecure. Without incorporating AD, only 10 out of 20 possible N-schemes remain. This is because the amount of possible generic compositions gets bigger if the authenticated encryption scheme has more inputs. Three of these 10 schemes were proven secure in this work, leaving 7 schemes to be evaluated.

\paragraph*{Adding associated Data}
In this work, the lAE construction was only evaluated without associated data (AD). To incorporate AD, a slight modification should be made to the definition of the lAE. With AD added, there will be 20 possible N-schemes, three of which will relate to the secure schemes from NRS. When evaluating the security, these three schemes should be prioritized as they have the highest likelihood of being secure. For a more rigorous analysis, all 20 schemes should be considered.

\paragraph*{Evaluating lAE with multiple uses}
The evaluation of the lAE construction was limited to a key that is used once. A more in-depth analysis could evaluate the construction in a setting where a key can be used multiple (but still limited) times. To maintain security, one would likely need to alter the lAE definition to also incorporate nonces. As the scheme will then have an additional input, a new set of possible compositions should be generated and evaluated. 

\paragraph*{Augmenting non-generic AE constructions with locks}
We found adaptation using locks to be secure for the generic composition of authenticated encryption. As a next step, one could look at whether non-generic AE constructions can be augmented with locks. When looking at the examples mentioned in Section \ref{sec: related work}, the augmented versions will most likely have lower computational cost when compared to generic composition. When proven secure, this will lead to more efficient instantiations of the lAE.

\paragraph*{Instantiating the lE and lMAC}
We discussed how an lAe can be constructed from an lE and a lMAC. Further research could investigate how these two building blocks can be implemented. The two id-based PRF functions discussed in Section \ref*{sec: related work} might be used as an lE. In this case, the lock value might be used as the id as the concepts are very similar. Furthermore, a nonce-based encryption primitive or nonce-based MAC function might be leveraged as an lE or a lMAC respectively. In this case, the lock value might be used as a nonce because we assume globally unique locks that are used only once.

\newpage
\printbibliography[heading=bibintoc,title={References}]

\appendix
\section{Proof of N2 and N3}\label{full_proofs}
In this appendix, the full proof of case N2 and N3 can be found.
\paragraph{N2}
First, we repeat Theorem 1 specifically for N2:
\begin{theorem}
Let lAE be constructed from lMAC and lE as described in Figure \ref{fig: N2 calls}. Let ciphertext space \ciphertextspace{} from the lE be a subset of message space \messagespace{} from the lMAC and let lMAC and lE have a shared lock space. Then, for any number of users \users{} and any lAE adversary \adversary{} that poses at most $Q_e$ many Oenc queries, and at most $Q_d$ many Odec queries, there exist a lMAC adversary $B$ and a lE adversary $C$ such that:
\textnormal{
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}} \leq \text{\advantage{$B$,\users}{lMAC}} + \text{\advantage{$C$,\users}{lE}} + \frac{Q_d}{2^{\text{n}}},
\end{align*}}
\hspace{-0,3cm} where \textnormal{n} is the output length of the lMAC in bits. The running time of $B$ is at most that of A plus the time required to run $Q_e$ many \textnormal{E.enc} encapsulations and $Q_d$ many \textnormal{E.dec} decapsulations. The running time of $C$ is at most that of \adversary. Additionally, $B$ makes at most $Q_e$ many Omac queries and at most $Q_d$ many Ovrf queries and $C$ makes at most $Q_e$ many Oenc queries.
\end{theorem}
\noindent
Within this theorem, both $Q_e$ and $Q_d$ refer to the total queries the adversary is allowed to make, not the queries per user. As a result, $Q_e$ is limited by \users.
\begin{proof}
To prove this theorem, we start by defining game lAE-N2 in Figure \ref{fig: lAE-N2 game}. This game is the game lAE-IND-\$-AE (Figure \ref{fig: lAE-IND game}), with AE.enc and AE.dec substituted with the N2 algorithms found in Figure \ref{fig: N2 calls}.
\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} lAE-N2$^{b}_{\adversary,\users}$ }]{
        L \result \emptyset\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace\\
        \t C_\user \result \invalid\\
        b' \result \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=5,linenumbering,head={\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            \ciphertextinstance' \result \text{E.enc}(\keyinstance{}1,\lockinstance_j,\messageinstance)\\
            \taginstance \result \text{M.mac}(\keyinstance{}2,\lockinstance_j,\ciphertextinstance')\\
            \ciphertextinstance \result (\ciphertextinstance',\taginstance)\\
            \pcif b = 1 \wedge \ciphertextinstance \neq \invalid: \\
            \t \ciphertextinstance \sample \{0,1\}^{\abs{\ciphertextinstance}}\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=17,linenumbering,head={\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcif C_\user = \invalid: \pcreturn \invalid\\
            \pcif \ciphertextinstance = C_\user: \pcreturn \invalid\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            (\ciphertextinstance',\taginstance) \result \ciphertextinstance\\
            \messageinstance \result \text{E.dec}(\keyinstance{}1,\lockinstance_j,\ciphertextinstance')\\
            \taginstance' \result \text{M.mac}(\keyinstance{}2,\lockinstance_j,\ciphertextinstance')\\
            \pcif \taginstance \neq \taginstance' : \messageinstance \result \invalid\\
            \pcif b = 1 : \messageinstance \result \invalid\\
            \pcreturn \messageinstance
        }
    \end{pchstack}
    \caption{lAE-N2 game, adversary{} has access to oracles Oenc and Odec.}
    \label{fig: lAE-N2 game}
\end{figure}

\noindent By definition, this gives us
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    =
    \text{Pr}[\text{lAE-N2}_{\text{\adversary,\users}}^0 =0]
    -
    \text{Pr}[\text{lAE-N2}_{\text{\adversary,\users}}^1 =0].
\end{align*}
Next we define game N2-switch-1 in Figure \ref{fig: N2-switch-1 game}. The only difference between this game and game lAE-N2$^0$ is the fact that N2-switch-1 uses the uniformly random function $tag$, instead of the lMAC. To define this function we write $\mathit{Func}(\keyspace \times \lockspace \times \ciphertextspace,\tagspace)$ to denote the set of all functions from the key space of the MAC \keyspace, the shared lock space \lockspace{} and ciphertext space from E.enc \ciphertextspace{} to the tag space \tagspace. We define this function specifically as we want the tags resulting from computations in oracle Oenc to match with those in oracle Odec. When the input of $tag$ is outside its domain, it will return \invalid.

\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} N2-switch-1$_{\adversary,\users}$ }]{
        L \result \emptyset\\
        tag \sample \mathit{Func}(\keyspace_{mac}\times \lockspace \times \ciphertextspace,\tagspace)\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace\\
        \t C_\user \result \invalid\\
        b' \result \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=6,linenumbering,head={\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            \ciphertextinstance' \result \text{E.enc}(\keyinstance{}1,\lockinstance_j,\messageinstance)\\
            \taginstance \result tag(\keyinstance{}2,\lockinstance_j,\ciphertextinstance')\\
            \ciphertextinstance \result (\ciphertextinstance',\taginstance)\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=16,linenumbering,head={\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcif C_\user = \invalid: \pcreturn \invalid\\
            \pcif \ciphertextinstance = C_\user: \pcreturn \invalid\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            (\ciphertextinstance',\taginstance) \result \ciphertextinstance\\
            \messageinstance \result \text{E.dec}(\keyinstance{}1,\lockinstance_j,\ciphertextinstance')\\
            \taginstance' \result tag(\keyinstance{}2,\lockinstance_j,\ciphertextinstance')\\
            \pcif \taginstance \neq \taginstance' : \messageinstance \result \invalid\\
            \pcreturn \messageinstance
        }
    \end{pchstack}
    \caption{N2-switch-1, adversary{} has access to oracles Oenc and Odec. 
    Key space $\keyspace_{mac}$ is the key space from M.mac. Lines 13 and 22 are different compared to lAE-N2$^0$, additionally lines 14, 15 and 25 from lAE-N2 are removed.}
    \label{fig: N2-switch-1 game}
\end{figure}

\noindent
Using this game, we expand the probability:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &=
    \text{Pr}[\text{lAE-N2}_{\text{\adversary,\users}}^0 =0]
    -
    \text{Pr}[\text{N2-switch-1}_{\text{\adversary,\users}} =0]
    \\&   + \text{Pr}[\text{N2-switch-1}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N2}_{\text{\adversary,\users}}^1 =0].
\end{align*}
Next, we can rewrite $\text{Pr}[\text{lAE-N2}_{\text{\adversary,\users}} =0] - \text{Pr}[\text{N2-switch-1}_{\text{\adversary,\users}} =0]$ into a lMAC advantage. To do so, we define adversary $B$ against lMAC in Figure \ref{fig: adversary B N2}. This adversary is playing game lMAC-PRF (Figure \ref{fig: lMAC-PRF game}), and has access to \adversary. 
\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Adverary} $B$}]{
        L \result \emptyset\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace_{enc}\\
        \t C_\user \result \invalid\\
        b' \result \textbf{run } \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=5,linenumbering,head={\text{if \adversary{} calls }\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            \ciphertextinstance' \result \text{E.enc}(\keyinstance_j,\lockinstance_j,\messageinstance)\\
            \taginstance \result \text{Omac}(\user,\lockinstance_j,\ciphertextinstance')\\
            \ciphertextinstance \result (\ciphertextinstance',\taginstance)\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=14,linenumbering,head={\text{if \adversary{} calls }\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcif C_\user = \invalid: \pcreturn \invalid\\
            \pcif \ciphertextinstance = C_\user: \pcreturn \invalid\\
            (\ciphertextinstance',\taginstance) \result \ciphertextinstance\\
            \messageinstance \result \text{E.dec}(\keyinstance{}_j,\lockinstance_j,\ciphertextinstance')\\
            passed \result \text{Ovrf}(\user,\ciphertextinstance',\taginstance')\\
            \pcif \neg passed : \messageinstance \result \invalid\\
            \pcreturn \messageinstance
        }
    \end{pchstack}
    \caption{Adversary $B$ has access to \adversary{} and oracles Omac and Ovrf. Key space $\keyspace_{enc}$ is the key space from E.enc.}
    \label{fig: adversary B N2}
\end{figure}

\noindent
The runtime of $B$ is that of $A$. For every Oenc query \adversary{} makes, $B$ computes E.enc once and calls Omac once. For every Odec query \adversary{} makes, $B$ computes E.dec once and calls Ovrf once. Note that, alternatively, $B$ could return 0 if $passed$ is \codetrue{} to avoid having to do E.dec computations. To increase consistency with the other two cases, these computations are still made. We can see that $\text{Pr}[\text{lMAC-PRF}_{\text{$B$,\users}}^0 =0]=\text{Pr}[\text{lAE-N2}_{\text{\adversary,\users}}^0 =0]$ as $B$ perfectly simulates game lAE-N2$^0$ when its own $b$ is 0. In addition, $\text{Pr}[\text{lMAC-PRF}_{\text{$B$,\users}}^1 =0]=\text{Pr}[\text{N2-switch-1}_{\text{\adversary,\users}} =0]$ as $B$ perfectly simulates game N2-switch-1 whenever its own $b$ is 1. As a result, we can rewrite our advantage to:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &=
    \text{Pr}[\text{lAE-N2}_{\text{\adversary,\users}}^0 =0]
    -
    \text{Pr}[\text{N2-switch-1}_{\text{\adversary,\users}} =0]
    \\&  + \text{Pr}[\text{N2-switch-1}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N2}_{\text{\adversary,\users}}^1 =0]
    \\& =
    \text{Pr}[\text{lMAC-PRF}_{\text{$B$,\users}}^0 =0]
    -
    \text{Pr}[\text{lMAC-PRF}_{\text{$B$,\users}}^1 =0]
    \\&          + \text{Pr}[\text{N2-switch-1}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N2}_{\text{\adversary,\users}}^1 =0]
    \\& = \text{\advantage{$B$,\users}{lMAC}}
    + \text{Pr}[\text{N2-switch-1}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N2}_{\text{\adversary,\users}}^1 =0].
\end{align*}
To expand our advantage again, we define game N2-switch-2 in Figure \ref{fig: N2-switch-2 game}. Apart from the Odec query, this game is equivalent to the first switch game. Although, the Odec oracle from N2-switch-2 always returns \invalid{}, it is written down more elaborately to include the event $bad$. This event is added to support a well-known proof tactic \cite{EC:BelRog06}. When expanded again, our advantage becomes:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &=
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{Pr}[\text{N2-switch-1}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{N2-switch-2}_{\text{\adversary,\users}} =0]
    \\& +
    \text{Pr}[\text{N2-switch-2}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N2}_{\text{\adversary,\users}}^1 =0].
\end{align*}
\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} N2-switch-2$_{\adversary,\users}$ }]{
        L \result \emptyset\\
        tag \sample \mathit{Func}(\keyspace_{mac}\times \lockspace \times \ciphertextspace,\tagspace)\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace\\
        \t C_\user \result \invalid\\
        b' \result \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=6,linenumbering,head={\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            \ciphertextinstance' \result \text{E.enc}(\keyinstance{}1,\lockinstance_j,\messageinstance)\\
            \taginstance \result tag(\keyinstance{}2,\lockinstance_j,\ciphertextinstance')\\
            \ciphertextinstance \result (\ciphertextinstance',\taginstance)\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=16,linenumbering,head={\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcif C_\user = \invalid: \pcreturn \invalid\\
            \pcif \ciphertextinstance = C_\user: \pcreturn \invalid\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            (\ciphertextinstance',\taginstance) \result \ciphertextinstance\\
            \messageinstance \result \text{E.dec}(\keyinstance{}1,\lockinstance_j,\ciphertextinstance')\\
            \taginstance' \result tag(\keyinstance{}2,\lockinstance_j,\ciphertextinstance')\\
            \pcif \taginstance \neq \taginstance' : \messageinstance \result \invalid\\
            \pcelse: \\
            \t bad \result \codetrue\\
            \t \messageinstance \result \invalid\\
            \pcreturn \messageinstance
        }
    \end{pchstack}
    \caption{N2-switch-2 game, adversary{} has access to oracles Oenc and Odec. Key space $\keyspace_{mac}$ is the key space from M.mac. Line 24-26 are different compared to N2-switch-1.}
    \label{fig: N2-switch-2 game}
\end{figure}
\noindent
As N2-switch-1 and N2-switch-2 are so called identical-until-$bad$ \cite{EC:BelRog06}, meaning they are equivalent as long as the event $bad$ is not set to \codetrue, we know:
\begin{align*}
    \text{Pr}[\text{N2-switch-1}_{\text{\adversary,\users}} =0]-\text{Pr}[\text{N2-switch-2}_{\text{\adversary,\users}} =0] \leq \text{Pr}[bad=\codetrue].
\end{align*}
Between the thick lines is the technical difference of current proof with the one of N1 in Section \ref{sec: sec prove}
\rule{5.8in}{1pt}\vspace{0,12cm}\\
As $bad$ is set to \codetrue{} if, and only if, \taginstance=\taginstance$'$, we can state $\text{Pr}[bad=\codetrue] = \text{Pr}[\taginstance=\taginstance']$. The adversary needs to provide tag \taginstance{} and ciphertext \ciphertextinstance$'$ for the $tag$ function, where the provided tag-ciphertext pair may not be the result of the encryption query corresponding to the provided user. Consequently, \taginstance{} and \taginstance$'$ are only equal when the adversary can guess the output of $tag$ for a ciphertext that is not encrypted for the provided user. The function $tag$ is uniformly random so, with every fresh ciphertext, the probability that \taginstance{} and \taginstance$'$ are equal is $\frac{1}{2^{\text{n}}}$. Summed over at most $Q_d$ Odec queries we get $\text{Pr}[\taginstance=\taginstance'] = \text{Pr}[bad=\codetrue] \leq \frac{Q_d}{2^{\text{n}}}$ and thus, we can use $\text{Pr}[\text{N2-switch-1}_{\text{\adversary,\users}} =0]-\text{Pr}[\text{N2-switch-2}_{\text{\adversary,\users}} =0] \leq \text{Pr}[bad=\codetrue] \leq \frac{Q_d}{2^{\text{n}}}$ to obtain:
\rule{5.8in}{1pt}\\
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &\leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{Pr}[\text{N2-switch-2}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N2}_{\text{\adversary,\users}}^1 =0]
    +
    \frac{Q_d}{2^{\text{n}}}.
\end{align*}
We define game N2-switch-3 in Figure \ref{fig: N2-switch-3 game} to expand our advantage one last time. Switch game 3 is equivalent to switch game 2 but always returns lazily sampled random bits when the outcome of E.enc is valid. It might seem like there is a difference as \taginstance{} can no longer become \invalid. This is not the case as, due to the chosen input spaces of $tag$, $tag$ can only return \invalid{} whenever \ciphertextinstance$'$ is already \invalid. As a result, $tag$ will never influence wether or not \ciphertextinstance{} on line 12 is \invalid. We also simplify Odec as we no longer need the event $bad$. We use this game to expand our advantage to:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &\leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{Pr}[\text{N2-switch-2}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{N2-switch-3}_{\text{\adversary,\users}} =0]
    \\& +
    \text{Pr}[\text{N2-switch-3}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N2}_{\text{\adversary,\users}}^1 =0]
    +
    \frac{Q_d}{2^{\text{n}}}.
\end{align*}
\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} N2-switch-3$_{\adversary,\users}$ }]{
        L \result \emptyset\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace_{enc}\\
        \t C_\user \result \invalid\\
        b' \result \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=5,linenumbering,head={\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            \ciphertextinstance' \result \text{E.enc}(\keyinstance{}j,\lockinstance_j,\messageinstance)\\
            \taginstance \sample \{0,1\}^{\text{n}}\\
            \ciphertextinstance \result (\ciphertextinstance',\taginstance)\\
            \pcif \ciphertextinstance \neq \invalid: \\
            \t \ciphertextinstance \sample \{0,1\}^{\abs{\ciphertextinstance}}\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=17,linenumbering,head={\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcreturn \invalid
        }
    \end{pchstack}
    \caption{N2-switch-3 game, adversary{} has access to oracles Oenc and Odec. Key space $\keyspace_{enc}$ is the key space from E.enc. Line 14 and 15 are different compared to N2-switch-2, and Odec is simplified.}
    \label{fig: N2-switch-3 game}
\end{figure}
\noindent
$\text{Pr}[\text{N2-switch-3}_{\text{\adversary,\users}} =0]$ and $\text{Pr}[\text{lAE-N2}_{\text{\adversary,\users}}^1 =0]$ are equivalent by definition, giving:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &\leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{Pr}[\text{N2-switch-2}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{N2-switch-3}_{\text{\adversary,\users}} =0]
    +
    \frac{Q_d}{2^{\text{n}}}.
\end{align*}
Next, we can rewrite $\text{Pr}[\text{N2-switch-2}_{\text{\adversary,\users}} =0] - \text{Pr}[\text{N2-switch-3}_{\text{\adversary,\users}} =0]$ into a lE advantage. To do so, we define adversary $C$ against lE in Figure \ref{fig: adversary c N2}. This adversary is playing game lE-IND-\$-CPA (Figure \ref{fig: lE-IND game}), and has access to \adversary. 
\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Adverary} $C$}]{
        L \result \emptyset\\
        \pcfor \user \in [1..N]:\\
        \t C_\user \result \invalid\\
        b' \result \textbf{run } \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=4,linenumbering,head={\text{if \adversary{} calls }\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            \ciphertextinstance' \result \text{Oenc}(\user,\lockinstance_j,\messageinstance)\\
            \taginstance \sample \{0,1\}^{\text{n}}\\
            \ciphertextinstance \result (\ciphertextinstance',\taginstance)\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=13,linenumbering,head={\text{if \adversary{} calls }\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcreturn \invalid
        }
    \end{pchstack}
    \caption{Adversary $C$ has access to \adversary{} and oracle Oenc. Note the Oenc in line 9 refers to the encryption oracle Oenc that $C$ has access to, not the oracle Oenc $A$ has access to.}
    \label{fig: adversary c N2}
\end{figure}
\noindent
The runtime of $C$ is that of $A$. For every Oenc query $A$ makes, $C$ makes one Oenc query. We can see that $\text{Pr}[\text{N2-switch-2}_{\text{\adversary,\users}} =0] = \text{Pr}[\text{lE-IND-\$-CPA}_{\text{$C$,\users}}^0 =0]$ as $C$ perfectly simulates N2-switch-2 when its own $b$ is 0. When its own $b$ is 1, $C$ perfectly simulates N2-switch-3 giving $\text{Pr}[\text{N2-switch-3}_{\text{\adversary,\users}} =0] = \text{Pr}[\text{lE-IND-\$-CPA}_{\text{$C$,\users}}^1 =0]$. This leads to:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &\leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{Pr}[\text{N2-switch-2}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{N2-switch-3}_{\text{\adversary,\users}} =0]
    +
    \frac{Q_d}{2^{\text{n}}}
    \\& \leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{Pr}[\text{lE-IND-\$-CPA}_{\text{$C$,\users}}^0 =0]
    -
    \text{Pr}[\text{lE-IND-\$-CPA}_{\text{$C$,\users}}^1 =0]
    +
    \frac{Q_d}{2^{\text{n}}}
    \\& \leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{\advantage{$C$,\users}{lE}}
    +
    \frac{Q_d}{2^{\text{n}}}.
\end{align*}
Thus proving:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &\leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{\advantage{$C$,\users}{lE}}
    +
    \frac{Q_d}{2^{\text{n}}}.\tag*{\qedhere}
\end{align*}
\end{proof}

\paragraph*{N3}
First, we repeat Theorem 1 specifically for N3:
\begin{theorem}
Let lAE be constructed from lMAC and lE as described in Figure \ref{fig: N3 calls}. Let ciphertext space \ciphertextspace{} from the lE be a subset of message space \messagespace{} from the lMAC and let lMAC and lE have a shared lock space. Then, for any number of users \users{} and any lAE adversary \adversary{} that poses at most $Q_e$ many Oenc queries, and at most $Q_d$ many Odec queries, there exist a lMAC adversary $B$ and a lE adversary $C$ such that:
\textnormal{
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}} \leq \text{\advantage{$B$,\users}{lMAC}} + \text{\advantage{$C$,\users}{lE}} + \frac{Q_d}{2^{\text{n}}},
\end{align*}}
\hspace{-0,3cm} where \textnormal{n} is the output length of the lMAC in bits. The running time of $B$ is at most that of A plus the time required to run $Q_e$ many \textnormal{E.enc} encapsulations and $Q_d$ many \textnormal{E.dec} decapsulations. The running time of $C$ is at most that of \adversary. Additionally, $B$ makes at most $Q_e$ many Omac queries and at most $Q_d$ many Ovrf queries and $C$ makes at most $Q_e$ many Oenc queries.
\end{theorem}
\noindent
Within this theorem, both $Q_e$ and $Q_d$ refer to the total queries the adversary is allowed to make, not the queries per user. As a result, $Q_e$ is limited by \users.
\begin{proof}
To prove this theorem, we start by defining game lAE-N3 in Figure \ref{fig: lAE-N3 game}. This game is the game lAE-IND-\$-AE (Figure \ref{fig: lAE-IND game}), with AE.enc and AE.dec substituted with the N3 algorithms found in Figure \ref{fig: N3 calls}.
\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} lAE-N3$^{b}_{\adversary,\users}$ }]{
        L \result \emptyset\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace\\
        \t C_\user \result \invalid\\
        b' \result \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=5,linenumbering,head={\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            \taginstance \result \text{M.mac}(\keyinstance{}2,\lockinstance_j,\messageinstance)\\
            \messageinstance' \result \messageinstance \concatinate \taginstance\\
            \ciphertextinstance \result \text{E.enc}(\keyinstance{}1,\lockinstance_j,\messageinstance')\\
            \pcif b = 1 \wedge \ciphertextinstance \neq \invalid: \\
            \t \ciphertextinstance \sample \{0,1\}^{\abs{\ciphertextinstance}}\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=17,linenumbering,head={\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcif C_\user = \invalid: \pcreturn \invalid\\
            \pcif \ciphertextinstance = C_\user: \pcreturn \invalid\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            \messageinstance' \result \text{E.dec}(\keyinstance{}1,\lockinstance_j,\ciphertextinstance)\\
            (\messageinstance,\taginstance) \result \messageinstance'\\
            \taginstance' \result \text{M.mac}(\keyinstance{}2,\lockinstance_j,\messageinstance)\\
            \pcif \taginstance \neq \taginstance' : \messageinstance \result \invalid\\
            \pcif b = 1 : \messageinstance \result \invalid\\
            \pcreturn \messageinstance
        }
    \end{pchstack}
    \caption{lAE-N3 game, adversary{} has access to oracles Oenc and Odec.}
    \label{fig: lAE-N3 game}
\end{figure}

\noindent By definition, this gives us
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    =
    \text{Pr}[\text{lAE-N3}_{\text{\adversary,\users}}^0 =0]
    -
    \text{Pr}[\text{lAE-N3}_{\text{\adversary,\users}}^1 =0].
\end{align*}
Next we define game N3-switch-1 in Figure \ref{fig: N3-switch-1 game}. The only difference between this game and game lAE-N3$^0$ is the fact that N3-switch-1 uses the uniformly random function $tag$, instead of the lMAC. To define this function we write $\mathit{Func}(\keyspace \times \lockspace \times \messagespace,\tagspace)$ to denote the set of all functions from the key space of the MAC \keyspace, the shared lock space \lockspace{} and the message space \messagespace{} to the tag space \tagspace. We define this function specifically as we want the tags resulting from computations in oracle Oenc to match with those in oracle Odec. When the input of $tag$ is outside its domain, it will return \invalid.

\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} N3-switch-1$_{\adversary,\users}$ }]{
        L \result \emptyset\\
        tag \sample \mathit{Func}(\keyspace_{mac}\times \lockspace \times \messagespace,\tagspace)\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace\\
        \t C_\user \result \invalid\\
        b' \result \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=6,linenumbering,head={\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            \taginstance \result tag(\keyinstance{}2,\lockinstance_j,\messageinstance)\\
            \messageinstance' \result \messageinstance \concatinate \taginstance\\
            \ciphertextinstance \result \text{E.enc}(\keyinstance{}1,\lockinstance_j,\messageinstance')\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=16,linenumbering,head={\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcif C_\user = \invalid: \pcreturn \invalid\\
            \pcif \ciphertextinstance = C_\user: \pcreturn \invalid\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            \messageinstance' \result \text{E.dec}(\keyinstance{}1,\lockinstance_j,\ciphertextinstance)\\
            (\messageinstance,\taginstance) \result \messageinstance'\\
            \taginstance' \result tag(\keyinstance{}2,\lockinstance_j,\messageinstance)\\
            \pcif \taginstance \neq \taginstance' : \messageinstance \result \invalid\\
            \pcreturn \messageinstance
        }
    \end{pchstack}
    \caption{N3-switch-1, adversary{} has access to oracles Oenc and Odec. 
    Key space $\keyspace_{mac}$ is the key space from M.mac. Lines 12 and 22 are different compared to lAE-N3$^0$, additionally lines 14, 15 and 25 from lAE-N3 are removed.}
    \label{fig: N3-switch-1 game}
\end{figure}

\noindent
Using this game, we expand the probability:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &=
    \text{Pr}[\text{lAE-N3}_{\text{\adversary,\users}}^0 =0]
    -
    \text{Pr}[\text{N3-switch-1}_{\text{\adversary,\users}} =0]
    \\&   + \text{Pr}[\text{N3-switch-1}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N3}_{\text{\adversary,\users}}^1 =0].
\end{align*}
Next, we can rewrite $\text{Pr}[\text{lAE-N3}_{\text{\adversary,\users}} =0] - \text{Pr}[\text{N3-switch-1}_{\text{\adversary,\users}} =0]$ into a lMAC advantage. To do so, we define adversary $B$ against lMAC in Figure \ref{fig: adversary B N3}. This adversary is playing game lMAC-PRF (Figure \ref{fig: lMAC-PRF game}), and has access to \adversary. 
\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Adverary} $B$}]{
        L \result \emptyset\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace_{enc}\\
        \t C_\user \result \invalid\\
        b' \result \textbf{run } \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=5,linenumbering,head={\text{if \adversary{} calls }\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            \taginstance \result \text{Omac}(\keyinstance{}_j,\lockinstance_j,\messageinstance)\\
            \messageinstance' \result \messageinstance \concatinate \taginstance\\
            \ciphertextinstance \result \text{E.enc}(\keyinstance{}_j,\lockinstance_j,\messageinstance')\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=14,linenumbering,head={\text{if \adversary{} calls }\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcif C_\user = \invalid: \pcreturn \invalid\\
            \pcif \ciphertextinstance = C_\user: \pcreturn \invalid\\
            \messageinstance' \result \text{E.dec}(\keyinstance,\lockinstance_j,\ciphertextinstance)\\
            (\messageinstance,\taginstance) \result \messageinstance'\\
            passed \result \text{Ovrf}(\user,\messageinstance, \taginstance)\\
            \pcif \neg passed : \messageinstance \result \invalid\\
            \pcreturn \messageinstance
        }
    \end{pchstack}
    \caption{Adversary $B$ has access to \adversary{} and oracles Omac and Ovrf. Key space $\keyspace_{enc}$ is the key space from E.enc.}
    \label{fig: adversary B N3}
\end{figure}

\noindent
The runtime of $B$ is that of $A$. For every Oenc query \adversary{} makes, $B$ computes E.enc once and calls Omac once. For every Odec query \adversary{} makes, $B$ computes E.dec once and calls Ovrf once. Note that, alternatively, $B$ could return 0 if $passed$ is \codetrue{} to avoid having to do E.dec computations. To increase consistency with the other two cases, these computations are still made. We can see that $\text{Pr}[\text{lMAC-PRF}_{\text{$B$,\users}}^0 =0]=\text{Pr}[\text{lAE-N3}_{\text{\adversary,\users}}^0 =0]$ as $B$ perfectly simulates game lAE-N3$^0$ = 0 when its own $b$ is 0. In addition, $\text{Pr}[\text{lMAC-PRF}_{\text{$B$,\users}}^1 =0]=\text{Pr}[\text{N3-switch-1}_{\text{\adversary,\users}} =0]$ as $B$ perfectly simulates game N3-switch-1 whenever its own $b$ is 1. As a result, we can rewrite our advantage to:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &=
    \text{Pr}[\text{lAE-N3}_{\text{\adversary,\users}}^0 =0]
    -
    \text{Pr}[\text{N3-switch-1}_{\text{\adversary,\users}} =0]
    \\&  + \text{Pr}[\text{N3-switch-1}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N3}_{\text{\adversary,\users}}^1 =0]
    \\& =
    \text{Pr}[\text{lMAC-PRF}_{\text{$B$,\users}}^0 =0]
    -
    \text{Pr}[\text{lMAC-PRF}_{\text{$B$,\users}}^1 =0]
    \\&  + \text{Pr}[\text{N3-switch-1}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N3}_{\text{\adversary,\users}}^1 =0]
    \\& = \text{\advantage{$B$,\users}{lMAC}}
    + \text{Pr}[\text{N3-switch-1}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N3}_{\text{\adversary,\users}}^1 =0].
\end{align*}
To expand our advantage again, we define game N3-switch-2 in Figure \ref{fig: N3-switch-2 game}. Apart from the Odec query, this game is equivalent to the first switch game. Although, the Odec oracle from N3-switch-2 always returns \invalid{}, it is written down more elaborately to include the event $bad$. This event is added to support a well-known proof tactic \cite{EC:BelRog06}. When expanded again, our advantage becomes:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &=
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{Pr}[\text{N3-switch-1}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{N3-switch-2}_{\text{\adversary,\users}} =0]
    \\& +
    \text{Pr}[\text{N3-switch-2}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N3}_{\text{\adversary,\users}}^1 =0].
\end{align*}
\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} N3-switch-2$_{\adversary,\users}$ }]{
        L \result \emptyset\\
        tag \sample \mathit{Func}(\keyspace_{mac}\times \lockspace \times \messagespace,\tagspace)\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace\\
        \t C_\user \result \invalid\\
        b' \result \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=6,linenumbering,head={\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            \taginstance \result tag(\keyinstance{}2,\lockinstance_j,\messageinstance)\\
            \messageinstance' \result \messageinstance \concatinate \taginstance\\
            \ciphertextinstance \result \text{E.enc}(\keyinstance{}1,\lockinstance_j,\messageinstance')\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=16,linenumbering,head={\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcif C_\user = \invalid: \pcreturn \invalid\\
            \pcif \ciphertextinstance = C_\user: \pcreturn \invalid\\
            (\keyinstance{}1,\keyinstance{}2) \result \keyinstance_j\\
            \messageinstance' \result \text{E.dec}(\keyinstance{}1,\lockinstance_j,\ciphertextinstance)\\
            (\messageinstance,\taginstance) \result \messageinstance'\\
            \taginstance' \result tag(\keyinstance{}2,\lockinstance_j,\messageinstance)\\
            \pcif \taginstance \neq \taginstance' : \messageinstance \result \invalid\\
            \pcelse: \\
            \t bad \result \codetrue\\
            \t \messageinstance \result \invalid\\
            \pcreturn \messageinstance
        }
    \end{pchstack}
    \caption{N3-switch-2 game, adversary{} has access to oracles Oenc and Odec. Key space $\keyspace_{mac}$ is the key space from M.mac. Line 24-26 are different compared to N3-switch-1.}
    \label{fig: N3-switch-2 game}
\end{figure}
\noindent
As N3-switch-1 and N3-switch-2 are so called identical-until-$bad$ \cite{EC:BelRog06}, meaning they are equivalent as long as the event $bad$ is not set to \codetrue, we know:
\begin{align*}
    \text{Pr}[\text{N3-switch-1}_{\text{\adversary,\users}} =0]-\text{Pr}[\text{N3-switch-2}_{\text{\adversary,\users}} =0] \leq \text{Pr}[bad=\codetrue].
\end{align*}
Between the thick lines is the technical difference of current proof with the one of N1 in Section \ref{sec: sec prove}
\rule{5.8in}{1pt}\vspace{0,12cm}\\
As $bad$ is set to \codetrue{} if, and only if, \taginstance=\taginstance$'$, we can state $\text{Pr}[bad=\codetrue] = \text{Pr}[\taginstance=\taginstance']$. 
The adversary needs to provide a ciphertext \ciphertextinstance$'$ that leads to a message \messageinstance{} that is used as input to the $tag$ function and a tag \taginstance. The provided ciphertext may not be the result of the encryption query corresponding to the provided user, which also ensures the message-tag pair derived from this ciphertext cannot be the message-tag pair that is encrypted for the provided user. Because the function $tag$ is uniformly random and the output needs to match with the newly obtained message-tag pair, the probability that \taginstance{} and \taginstance$'$ are equal is $\frac{1}{2^{\text{n}}}$ with every fresh Odec query. Summed over at most $Q_d$ Odec queries we get $\text{Pr}[\taginstance=\taginstance'] = \text{Pr}[bad=\codetrue] \leq \frac{Q_d}{2^{\text{n}}}$ and thus, we can use $\text{Pr}[\text{N3-switch-1}_{\text{\adversary,\users}} =0]-\text{Pr}[\text{N3-switch-2}_{\text{\adversary,\users}} =0] \leq \text{Pr}[bad=\codetrue] \leq \frac{Q_d}{2^{\text{n}}}$ to obtain:
\rule{5.8in}{1pt}
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &\leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{Pr}[\text{N3-switch-2}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N3}_{\text{\adversary,\users}}^1 =0]
    +
    \frac{Q_d}{2^{\text{n}}}.
\end{align*}
We define game N3-switch-3 in Figure \ref{fig: N3-switch-3 game} to expand our advantage one last time. Switch game 3 is equivalent to switch game 2 but always returns lazily sampled random bits when the outcome of E.enc is valid. It might seem like there is a difference as \taginstance{} can no longer become \invalid. This is not the case as, due to the chosen input spaces of $tag$, $tag$ can only return \invalid{} whenever \ciphertextinstance$'$ is already \invalid. As a result, $tag$ will never influence wether or not \ciphertextinstance{} on line 13 is \invalid. We also simplify Odec as we no longer need the event $bad$. We use this game to expand our advantage to:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &\leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{Pr}[\text{N3-switch-2}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{N3-switch-3}_{\text{\adversary,\users}} =0]
    \\& +
    \text{Pr}[\text{N3-switch-3}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{lAE-N3}_{\text{\adversary,\users}}^1 =0]
    +
    \frac{Q_d}{2^{\text{n}}}.
\end{align*}
\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Game} N3-switch-3$_{\adversary,\users}$ }]{
        L \result \emptyset\\
        \pcfor \user \in [1..N]:\\
        \t \keyinstance_\user \sample \keyspace_{enc}\\
        \t C_\user \result \invalid\\
        b' \result \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=5,linenumbering,head={\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            \taginstance \sample \{0,1\}^{\text{n}}\\
            \messageinstance' \result \messageinstance \concatinate \taginstance\\
            \ciphertextinstance \result \text{E.enc}(\keyinstance{}_j,\lockinstance,\messageinstance')\\
            \pcif \ciphertextinstance \neq \invalid: \\
            \t \ciphertextinstance \sample \{0,1\}^{\abs{\ciphertextinstance}}\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=17,linenumbering,head={\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcreturn \invalid
        }
    \end{pchstack}
    \caption{N3-switch-3 game, adversary{} has access to oracles Oenc and Odec. Key space $\keyspace_{enc}$ is the key space from E.enc. Line 14 and 15 are different compared to N3-switch-2, and Odec is simplified.}
    \label{fig: N3-switch-3 game}
\end{figure}
\noindent
$\text{Pr}[\text{N3-switch-3}_{\text{\adversary,\users}} =0]$ and $\text{Pr}[\text{lAE-N3}_{\text{\adversary,\users}}^1 =0]$ are equivalent by definition, giving:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &\leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +   
    \text{Pr}[\text{N3-switch-2}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{N3-switch-3}_{\text{\adversary,\users}} =0]
    +
    \frac{Q_d}{2^{\text{n}}}.
\end{align*}
Next, we can rewrite $\text{Pr}[\text{N3-switch-2}_{\text{\adversary,\users}} =0] - \text{Pr}[\text{N3-switch-3}_{\text{\adversary,\users}} =0]$ into a lE advantage. To do so, we define adversary $C$ against lE in Figure \ref{fig: adversary c N3}. This adversary is playing game lE-IND-\$-CPA (Figure \ref{fig: lE-IND game}), and has access to \adversary. 
\begin{figure}[H]
    \begin{pchstack}[boxed,center,space=0.5cm]
        \pseudocode[lnstart=-1,linenumbering,head={\textbf{Adverary} $C$}]{
        L \result \emptyset\\
        \pcfor \user \in [1..N]:\\
        \t C_\user \result \invalid\\
        b' \result \textbf{run } \adversary\\
        \pcreturn b'
        }
        \pseudocode[lnstart=4,linenumbering,head={\text{if \adversary{} calls }\textbf{Oracle} Oenc$(\user,\lockinstance,\messageinstance)$}]{
            \pcif C_\user \neq \invalid: \pcreturn \invalid\\
            \pcif \lockinstance \in L: \pcreturn \invalid\\
            L \result L \cup \{\lockinstance\}\\
            \lockinstance_\user \result \lockinstance\\
            \taginstance \sample \{0,1\}^{\text{n}}\\
            \messageinstance' \result \messageinstance \concatinate \taginstance\\
            \ciphertextinstance \result \text{Oenc}(\user,\lockinstance,\messageinstance')\\
            C_\user \result \ciphertextinstance\\
            \pcreturn \ciphertextinstance
        }
        \pseudocode[lnstart=13,linenumbering,head={\text{if \adversary{} calls }\textbf{Oracle} Odec$(\user,\ciphertextinstance)$}]{
            \pcreturn \invalid
        }
    \end{pchstack}
    \caption{Adversary $C$ has access to \adversary{} and oracle Oenc. Note the Oenc in line 11 refers to the encryption oracle Oenc that $C$ has access to, not the oracle Oenc $A$ has access to.}
    \label{fig: adversary c N3}
\end{figure}
\noindent
The runtime of $C$ is that of $A$. For every Oenc query $A$ makes, $C$ makes one Oenc query. We can see that $\text{Pr}[\text{N3-switch-2}_{\text{\adversary,\users}} =0] = \text{Pr}[\text{lE-IND-\$-CPA}_{\text{$C$,\users}}^0 =0]$ as $C$ perfectly simulates N3-switch-2 when its own $b$ is 0. When its own $b$ is 1, $C$ perfectly simulates N3-switch-3 giving  $\text{Pr}[\text{N3-switch-3}_{\text{\adversary,\users}} =0] = \text{Pr}[\text{lE-IND-\$-CPA}_{\text{$C$,\users}}^1 =0]$. This leads to:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &\leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{Pr}[\text{N3-switch-2}_{\text{\adversary,\users}} =0]
    -
    \text{Pr}[\text{N3-switch-3}_{\text{\adversary,\users}} =0]
    +
    \frac{Q_d}{2^{\text{n}}}
    \\& \leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{Pr}[\text{lE-IND-\$-CPA}_{\text{$C$,\users}}^0 =0]
    -
    \text{Pr}[\text{lE-IND-\$-CPA}_{\text{$C$,\users}}^1 =0]
    +
    \frac{Q_d}{2^{\text{n}}}
    \\& \leq
    \text{\advantage{$B$,\users}{lMAC}} 
    +
    \text{\advantage{$C$,\users}{lE}}
    +
    \frac{Q_d}{2^{\text{n}}}.
\end{align*}
Thus proving:
\begin{align*}
    \text{\advantage{$A$,\users}{lAE}}
    &\leq
    \text{\advantage{$B$,\users}{lMAC}}
    +
    \text{\advantage{$C$,\users}{lE}}
    +
    \frac{Q_d}{2^{\text{n}}}.\tag*{\qedhere}
\end{align*}
\end{proof}
\end{document}

\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{rutitlepage}[2022/02/21 Mart Lubbers]
\RequirePackage{geometry,graphicx,ifpdf,keyval,iflang}
\def\@rutitleauthors{\@author}
\def\@rutitleauthorstext{Aut\IfLanguageName{dutch}{eu}{ho}r:}
\def\@rutitledate{\@date}
\def\@rutitleinst{Radboud Universit\IfLanguageName{dutch}{eit}{y} Nijmegen}
\def\@rutitletitle{\@title}
\def\@rutitlelayout{twentytwo}
\newif\if@rutitlecolour\@rutitlecolourfalse
\define@key{maketitleru}{authors}{\def\@rutitleauthors{#1}}
\define@key{maketitleru}{authorstext}{\def\@rutitleauthorstext{#1}}
\define@key{maketitleru}{colour}[true]{\@rutitlecolourtrue}
\define@key{maketitleru}{course}{\def\@rutitlecourse{#1}}
\define@key{maketitleru}{date}{\def\@rutitledate{#1}}
\define@key{maketitleru}{institution}{\def\@rutitleinst{#1}}
\define@key{maketitleru}{layout}{\def\@rutitlelayout{#1}}
\define@key{maketitleru}{nextpagenr}{\def\@rutitlenextpagenr{#1}}
\define@key{maketitleru}{others}{\def\@rutitleothers{#1}}
\define@key{maketitleru}{subtitle}{\def\@rutitlesubtitle{#1}}
\define@key{maketitleru}{title}{\def\@rutitletitle{#1}}
\newcommand*{\rutitlepage@printothers}[2]{\textit{#1}\\#2}
\newcommand*{\rutitlepage@sepothers}{\\[\baselineskip]}
\newcommand*{\rutitlepage@others}[2]{%
	\rutitlepage@printothers{#1}{#2}%
	\kernel@ifnextchar,{\rutitlepage@sepothers\rutitlepage@otherslist@}\relax}
\newcommand*{\rutitlepage@otherslist}[1]{%
	\expandafter\rutitlepage@others#1}
\def\rutitlepage@otherslist@,#1{\rutitlepage@otherslist{{#1}}}
\newcommand{\rutitle@layout@twentytwo}[0]{
	\newgeometry{left=25mm,top=25mm,right=15mm,bottom=10mm,hmarginratio=1:1}
	\begin{titlepage}%
		\null\vfill%
		\parindent0pt
		\ifdefined\@rutitlecourse\textsc{\LARGE\@rutitlecourse}\\[1.5cm]\fi
		{\Huge\bfseries\@rutitletitle}%
		\ifdefined\@rutitlesubtitle{\\[2\baselineskip]\large\itshape\@rutitlesubtitle\/}\fi\\[4\baselineskip]
		{\Large\scshape\@rutitleauthors}\\[\baselineskip]
		{\large\@rutitledate}
		\vfill

		\ifdefined\@rutitleothers\rutitlepage@otherslist\@rutitleothers\fi
		\vfill

		\hfill
		\ifpdf\includegraphics[width=80mm]{rutitlepage-logo-\IfLanguageName{dutch}{nl-}{}\if@rutitlecolour cmyk\else bw\fi.pdf}\\
		\else\includegraphics[width=80mm]{rutitlepage-logo-\IfLanguageName{dutch}{nl-}{}\if@rutitlecolour cmyk\else bw\fi.eps}\\
		\fi
	\end{titlepage}
	\restoregeometry%
}
\newcommand{\rutitle@layout@seventeen}[0]{
	\newgeometry{left=25mm,top=25mm,right=15mm,bottom=10mm,hmarginratio=1:1}
	\begin{titlepage}%
		\null\vfill%
		\parindent0pt
		{\Huge\bfseries\@rutitletitle}%
		\ifdefined\@rutitlesubtitle{\\[2\baselineskip]\large\itshape\@rutitlesubtitle\/}\fi\\[4\baselineskip]
		{\Large\scshape\@rutitleauthors}\\[\baselineskip]
		{\large\@rutitledate}
		\vfill

		\ifdefined\@rutitleothers\rutitlepage@otherslist\@rutitleothers\fi
		\vfill

		\hfill
		\ifpdf\includegraphics[width=80mm]{rutitlepage-logo-\IfLanguageName{dutch}{nl-}{}\if@rutitlecolour cmyk\else bw\fi.pdf}\\
		\else\includegraphics[width=80mm]{rutitlepage-logo-\IfLanguageName{dutch}{nl-}{}\if@rutitlecolour cmyk\else bw\fi.eps}\\
		\fi
	\end{titlepage}
	\restoregeometry%
}
\newcommand{\rutitle@layout@traditional}[0]{
	\newgeometry{hmarginratio=1:1}
	\begin{titlepage}
		\begin{center}
			\ifdefined\@rutitlecourse\textsc{\LARGE\@rutitlecourse}\\[1.5cm]\fi
			\ifpdf\includegraphics[height=150pt]{rutitlepage-logo.pdf}\\
			\else\includegraphics[height=150pt]{rutitlepage-logo.eps}\\
			\fi
			\vspace{0.4cm}
			\textsc{\Large\@rutitleinst}\\[1cm]
			\hrule
			\vspace{0.4cm}
			\textbf{\large\@rutitletitle}\\[0.4cm]
			\hrule
			\ifdefined\@rutitlesubtitle
				\vspace{0.4cm}
				\textit{\@rutitlesubtitle}\\[1cm]
			\else
				\vspace{2cm}
			\fi
			\begin{minipage}[t]{0.45\textwidth}
				\begin{flushleft}\large
					\textit{\@rutitleauthorstext}\\
					\@rutitleauthors{}
				\end{flushleft}
			\end{minipage}
			\begin{minipage}[t]{0.45\textwidth}
				\begin{flushright}\large
					\ifdefined\@rutitleothers
					\renewcommand{\rutitlepage@printothers}[2]{\textit{##1}\\##2}
					\renewcommand{\rutitlepage@sepothers}[0]{

						\vspace{8mm}}
					\rutitlepage@otherslist\@rutitleothers
					\fi
				\end{flushright}
			\end{minipage}
			\vfill
			{\large\@rutitledate}
		\end{center}
	\end{titlepage}
	\restoregeometry%
}
\newcommand{\maketitleru}[1][]{
	\setkeys{maketitleru}{#1}
	\ifcsname%
		rutitle@layout@\@rutitlelayout\endcsname
		\expandafter\csname rutitle@layout@\@rutitlelayout\endcsname
	\else
		\PackageError{rutitlepage}
			{Unknown layout `\@rutitlelayout'.}
			{The `layout' key of \maketitleru\space contained an unknown layout.\MessageBreak{}
			 Check the package documentation for the possible layouts.}
	\fi
	\ifdefined\@rutitlenextpagenr\setcounter{page}{\@rutitlenextpagenr}\fi%
}